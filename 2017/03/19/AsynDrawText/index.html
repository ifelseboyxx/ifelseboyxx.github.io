<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> iOS 优化界面流畅性的那些事儿 · ifelseboyxx's Blog</title><meta name="description" content="iOS 优化界面流畅性的那些事儿 - ifelseboyxx"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/user.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="ifelseboyxx's Blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/img_header.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/3224111110/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo&amp;is_all=1" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/ifelseboyxx" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="http://www.jianshu.com/u/c1fef1c0da1a" target="_blank" class="nav-list-link">JIANSHU</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">iOS 优化界面流畅性的那些事儿</h1><div class="post-info">2017年3月19日</div><div class="post-content"><p>前段时间忙于业务开发，最近终于有时间优化优化卡顿的界面，话不多说先来看看界面的样子：</p>
<p><img src="/images/UI.png" alt=""></p>
<p>界面不算复杂，控件元素却很多，第一眼看上去，有点经验的会立马在脑海中分析起来：整个 cell 可以分为上、中、下三部分，上面主要就是一些 <code>UILabel</code>，中间和下面部分就是一些 <code>UIButton</code>，最简单方便的就是用 <code>UICollectionView</code> 来实现，最后 cell 拖个 <code>xib</code>，再用 <code>Autolayout</code> 设置下约束基本上也就差不多了。事实上，第一版本这个界面我的确就是这么实现的，好处就是实现起来很快，但是缺点就是导致界面滚动起来有点卡顿，虽然 PM 表示还可以接受，但是对于经常玩新浪微博的我，每当我看到微博那杀手级别的流畅性能时，内心总是有点惭愧，加上这个版本不算太忙，于是针对这个界面做了优化，顺便总结了下优化的过程，也算对自己学习过程的一个记录。</p>
<a id="more"></a>
<h4 id="高度预计算"><a href="#高度预计算" class="headerlink" title="高度预计算"></a>高度预计算</h4><p>优化的第一件事情就是<strong>舍弃了 <code>Autolayout</code> 技术</strong>，所有控件的 <code>frame</code> 全部在数据请求回来时，异步手动计算并缓存到内存中去以备使用。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">OrderServiceTopViewFrameModel</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"><span class="comment">/** 图标 frame*/</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>) <span class="built_in">CGRect</span> iconFrame;</div><div class="line"></div><div class="line"><span class="comment">/** 标题 frame*/</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>) <span class="built_in">CGRect</span> titleFrame;</div><div class="line"></div><div class="line"><span class="comment">/** 价格 frame*/</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>) <span class="built_in">CGRect</span> priceFrame;</div><div class="line"></div><div class="line"><span class="comment">/** 订单状态 frame*/</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>) <span class="built_in">CGRect</span> stateFrame;</div><div class="line"></div><div class="line"><span class="comment">/** 箭头 frame*/</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>) <span class="built_in">CGRect</span> arrowFrame;</div><div class="line"></div><div class="line"><span class="comment">/** 第一个副标 frame*/</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>) <span class="built_in">CGRect</span> subFirstTitleFrame;</div><div class="line"></div><div class="line"><span class="comment">/** 第二个副标 frame*/</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>) <span class="built_in">CGRect</span> subSecondTitleFrame;</div><div class="line"></div><div class="line"><span class="comment">/** 自己的 frame*/</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>) <span class="built_in">CGRect</span> topViewFrame;</div><div class="line"></div><div class="line"><span class="comment">/** 数据 model*/</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) MyOrderListCellItem&lt;MyOrderListCellItem&gt; *cellItem;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//icon</span></div><div class="line"><span class="keyword">static</span> <span class="built_in">NSInteger</span> <span class="keyword">const</span> kIocn_height = <span class="number">25.0</span>f; <span class="comment">//宽</span></div><div class="line"><span class="keyword">static</span> <span class="built_in">NSInteger</span> <span class="keyword">const</span> kIocn_width = kIocn_height; <span class="comment">//高</span></div><div class="line"><span class="keyword">static</span> <span class="built_in">NSInteger</span> <span class="keyword">const</span> kIcon_x = <span class="number">15.0</span>f; <span class="comment">// x</span></div><div class="line"><span class="keyword">static</span> <span class="built_in">NSInteger</span> <span class="keyword">const</span> kIcon_y = <span class="number">10.0</span>f; <span class="comment">// y</span></div><div class="line"></div><div class="line"><span class="comment">//price</span></div><div class="line"><span class="keyword">static</span> <span class="built_in">NSInteger</span> <span class="keyword">const</span> kPriceRight = <span class="number">15.0</span>f; <span class="comment">//价格 居右间距</span></div><div class="line"></div><div class="line"><span class="comment">//state</span></div><div class="line"><span class="keyword">static</span> <span class="built_in">NSInteger</span> <span class="keyword">const</span> kStateRight = kPriceRight; <span class="comment">//订单状态 居右间距</span></div><div class="line"></div><div class="line"><span class="comment">//title</span></div><div class="line"><span class="keyword">static</span> <span class="built_in">NSInteger</span> <span class="keyword">const</span> kTitleLeft = <span class="number">15.0</span>f; <span class="comment">//标题 左间距</span></div><div class="line"><span class="keyword">static</span> <span class="built_in">NSInteger</span> <span class="keyword">const</span> kTitleRight = <span class="number">10.0</span>f;<span class="comment">//标题 右间距</span></div><div class="line"><span class="keyword">static</span> <span class="built_in">NSInteger</span> <span class="keyword">const</span> kTitle_y = <span class="number">13.0</span>f; <span class="comment">//标题 上间距</span></div><div class="line"><span class="keyword">static</span> <span class="built_in">NSInteger</span> <span class="keyword">const</span> kTitleMaxHeight = <span class="number">34.0</span>f; <span class="comment">//标题最大高度</span></div><div class="line"></div><div class="line"><span class="comment">//标签</span></div><div class="line"><span class="keyword">static</span> <span class="built_in">NSInteger</span> <span class="keyword">const</span> kTagHeight = <span class="number">15.0</span>f; <span class="comment">//标签高度</span></div><div class="line"><span class="keyword">static</span> <span class="built_in">NSInteger</span> <span class="keyword">const</span> kTagSpace = <span class="number">5.0</span>f; <span class="comment">// 两个标签间距</span></div><div class="line"><span class="keyword">static</span> <span class="built_in">NSInteger</span> <span class="keyword">const</span> kTagTop = <span class="number">4.0</span>f; <span class="comment">//标签居上</span></div><div class="line"><span class="keyword">static</span> <span class="built_in">NSInteger</span> <span class="keyword">const</span> kTagBottom = <span class="number">9.0</span>f; <span class="comment">//标签居下</span></div><div class="line"></div><div class="line"><span class="comment">//副标题</span></div><div class="line"><span class="keyword">static</span> <span class="built_in">NSInteger</span> <span class="keyword">const</span> kSubTitleSpace = <span class="number">2.0</span>f; <span class="comment">//两个副标题之间的间距</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">OrderServiceTopViewFrameModel</span></span></div><div class="line"></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setCellItem:(MyOrderListCellItem&lt;MyOrderListCellItem&gt; *)cellItem</div><div class="line">&#123;</div><div class="line">    _cellItem = cellItem;</div><div class="line">    </div><div class="line">    <span class="comment">//icon frame</span></div><div class="line">    <span class="keyword">self</span>.iconFrame = <span class="built_in">CGRectMake</span>(kIcon_x, kIcon_y, kIocn_width, kIocn_height);</div><div class="line">    </div><div class="line">    <span class="comment">//价格 size</span></div><div class="line">    <span class="built_in">NSString</span> *priceStr = <span class="string">@""</span>;</div><div class="line">    <span class="keyword">if</span> (cellItem.orderListAll.amount.length &gt; <span class="number">0</span>) &#123;</div><div class="line">        priceStr =  [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"¥%@"</span>,cellItem.orderListAll.amount];</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        priceStr = <span class="string">@""</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">CGSize</span> priceSize = [priceStr sizeWithAttributes:@&#123;<span class="built_in">NSFontAttributeName</span>:font_List&#125;];</div><div class="line">    </div><div class="line">    <span class="comment">//订单状态 size</span></div><div class="line">    <span class="built_in">NSString</span> *strStatus = cellItem.orderListAll.orderStatus;</div><div class="line">    <span class="built_in">CGSize</span> stateSize = [strStatus sizeWithAttributes:@&#123;<span class="built_in">NSFontAttributeName</span> : font_Hint&#125;];</div><div class="line">    </div><div class="line">    <span class="comment">//标题 frame</span></div><div class="line">    <span class="built_in">CGFloat</span> tempWidth = (priceSize.width &gt; stateSize.width) ? priceSize.width : stateSize.width;</div><div class="line">    <span class="built_in">CGFloat</span> titleX = <span class="built_in">CGRectGetMaxX</span>(<span class="keyword">self</span>.iconFrame) + kTitleLeft;</div><div class="line">    <span class="built_in">CGFloat</span> titleY = kTitle_y;</div><div class="line">    <span class="built_in">CGFloat</span> titleW = kCardWidth - titleX - kTitleRight - tempWidth - kPriceRight;</div><div class="line">    <span class="built_in">CGRect</span> rect = [cellItem.orderListAll.title boundingRectWithSize:<span class="built_in">CGSizeMake</span>(titleW, kTitleMaxHeight) options:<span class="built_in">NSStringDrawingUsesLineFragmentOrigin</span>|<span class="built_in">NSStringDrawingUsesFontLeading</span> attributes:@&#123;<span class="built_in">NSFontAttributeName</span>:font_Info_Bold&#125; context:<span class="literal">nil</span>];</div><div class="line">    <span class="built_in">CGFloat</span> titleH = rect.size.height;</div><div class="line">    <span class="keyword">self</span>.titleFrame = <span class="built_in">CGRectMake</span>(titleX, titleY, titleW, titleH);</div><div class="line">    </div><div class="line">    <span class="comment">//价格 frame</span></div><div class="line">    <span class="built_in">CGFloat</span> priceX = kCardWidth - priceSize.width-(kPriceRight);</div><div class="line">    <span class="built_in">CGFloat</span> priceW = priceSize.width;</div><div class="line">    <span class="built_in">CGFloat</span> priceH = priceSize.height;</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="comment">//订单状态 frame</span></div><div class="line">    <span class="built_in">CGFloat</span> stateX = kCardWidth - stateSize.width - kStateRight;</div><div class="line">    <span class="built_in">CGFloat</span> stateW = stateSize.width;</div><div class="line">    <span class="built_in">CGFloat</span> stateH = stateSize.height;</div><div class="line">    <span class="comment">//状态 frame</span></div><div class="line">    <span class="keyword">self</span>.stateFrame = <span class="built_in">CGRectMake</span>(stateX, kTitle_y, stateW, stateH);</div><div class="line">    </div><div class="line">  </div><div class="line">    </div><div class="line">    <span class="built_in">CGFloat</span> tageTwoX = <span class="built_in">CGRectGetMaxX</span>(<span class="keyword">self</span>.tagOneFrame) + kTagSpace;</div><div class="line">    <span class="built_in">CGFloat</span> tageTwoY = <span class="built_in">CGRectGetMaxY</span>(<span class="keyword">self</span>.titleFrame) + tagTopTwo;</div><div class="line">    <span class="built_in">CGFloat</span> tageTwoW = tageTwoSize.width + <span class="number">8.0</span>f;<span class="comment">//这边 ＋ 8 算上边距</span></div><div class="line">    <span class="built_in">CGFloat</span> tageTwoH = kTagHeight;</div><div class="line">    <span class="keyword">self</span>.tagTwoFrame = <span class="built_in">CGRectMake</span>(tageTwoX, tageTwoY, tageTwoW, tageTwoH);</div><div class="line">    </div><div class="line">    </div><div class="line">    					···········</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="comment">/** 自己的 frame*/</span></div><div class="line">    <span class="keyword">self</span>.topViewFrame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, kCardWidth, <span class="built_in">CGRectGetMaxY</span>(<span class="keyword">self</span>.subSecondTitleFrame));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>上面的代码可以看到，计算控件宽高主要是用到了 <code>TextKit</code> 里面的两个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">CGSize</span>)sizeWithAttributes:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)attrs <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_0, <span class="number">7</span>_0);</div><div class="line"></div><div class="line">- (<span class="built_in">CGRect</span>)boundingRectWithSize:(<span class="built_in">CGSize</span>)size options:(<span class="built_in">NSStringDrawingOptions</span>)options attributes:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)attributes context:(<span class="keyword">nullable</span> <span class="built_in">NSStringDrawingContext</span> *)context <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_11, <span class="number">7</span>_0);</div></pre></td></tr></table></figure>
<p>用的时候直接取出 <code>frame</code> ：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setTopframeModel:(OrderServiceTopViewFrameModel *)topframeModel</div><div class="line">&#123;</div><div class="line">    _topframeModel = topframeModel;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (!topframeModel) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//icon</span></div><div class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:topframeModel.cellItem.orderListAll.iconUrl];</div><div class="line">    [<span class="keyword">self</span>.icon sd_setImageWithURL:url placeholderImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"icon_default_order"</span>]];</div><div class="line">    <span class="keyword">self</span>.icon.frame = topframeModel.iconFrame;</div><div class="line">    </div><div class="line">    <span class="comment">//title</span></div><div class="line">    <span class="keyword">if</span> (topframeModel.cellItem.orderListAll.title.length) &#123;</div><div class="line">        <span class="keyword">self</span>.lblTitle.text = topframeModel.cellItem.orderListAll.title;</div><div class="line">        <span class="keyword">self</span>.lblTitle.frame = topframeModel.titleFrame;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">self</span>.lblTitle.text = <span class="string">@""</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//price</span></div><div class="line">    <span class="keyword">if</span> (topframeModel.cellItem.orderListAll.amount.length &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.lblPrice.text = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"¥%@"</span>,topframeModel.cellItem.orderListAll.amount];</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">self</span>.lblPrice.text = <span class="string">@""</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">self</span>.lblPrice.frame = topframeModel.priceFrame;</div><div class="line">    </div><div class="line">    <span class="comment">//state</span></div><div class="line">    <span class="keyword">if</span> (topframeModel.cellItem.orderListAll.orderStatus.length &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.lblState.text = topframeModel.cellItem.orderListAll.orderStatus;</div><div class="line">        <span class="keyword">self</span>.lblState.frame = topframeModel.stateFrame;</div><div class="line">        <span class="keyword">self</span>.lblState.textColor = [<span class="keyword">self</span> strTopRightStatusWithModel:topframeModel];</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">self</span>.lblState.text = <span class="string">@""</span>;</div><div class="line">    &#125;    </div><div class="line">    				........</div></pre></td></tr></table></figure>
<h4 id="轻量化-cell"><a href="#轻量化-cell" class="headerlink" title="轻量化 cell"></a>轻量化 cell</h4><p>cell 中尽量不要再嵌套 UITableView 和 UICollectionView，不断的 <code>reloadData</code> 对性能影响是很大的。采用更加轻量的 <code>UIView + UIButton</code> 或者 <code>UIView + UILabel</code> 形式来自定义控件，牺牲些开发速度，提高性能。</p>
<h4 id="采用高效的圆角方式"><a href="#采用高效的圆角方式" class="headerlink" title="采用高效的圆角方式"></a>采用高效的圆角方式</h4><p><a href="http://www.jianshu.com/u/3e55748920d2" target="_blank" rel="external">bestswifter</a> 的 <a href="http://www.jianshu.com/p/f970872fdc22" target="_blank" rel="external">iOS 高效添加圆角效果实战讲解</a> 这篇文章中提到：</p>
<blockquote>
<p>设置圆角很简单，它不会带来任何性能损耗</p>
</blockquote>
<p>下面这句代码并不会影响性能：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">view.layer.cornerRadius = <span class="number">5</span></div></pre></td></tr></table></figure>
<p>真正影响性能的是下面这句：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">label.layer.masksToBounds = <span class="literal">true</span></div></pre></td></tr></table></figure>
<p>结合我的界面来看：中间部分因为 view 的底色也是白色，并且不需要 <code>Highlighted</code> 效果， 所以直接设置 <code>cornerRadius</code> 就能满足要求；而对于下面的部分，因为按钮是有 <code>Normal</code> 和 <code>Highlighted</code> 状态背景色的，如果不设置 <code>masksToBounds</code>，高亮时会有矩形的四个角漏出来，所以我这边直接是让 UI 切了图片的方式来实现，简单粗暴。</p>
<h4 id="文本异步渲染"><a href="#文本异步渲染" class="headerlink" title="文本异步渲染"></a>文本异步渲染</h4><p>其实做完上面这三点，列表流畅度其实已经算可以接受了，但是和新浪微博这种还是有很大的差距的，我也一直在思考怎么能更上一层楼，直到我看到了<a href="https://github.com/ibireme" target="_blank" rel="external">ibireme</a> 的 <a href="http://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/" target="_blank" rel="external">《iOS 保持界面流畅的技巧》</a>，这篇文章我很早之前就看过，只是当时并没有很好地消化。事实也证明好的文章读一遍是完全不够的，然后我又从头到尾仔细的读了读，最后锁定在<strong>异步渲染</strong>上。</p>
<p>在异步渲染之前，有必要先了解下绘制过程，<a href="http://vizlabxt.github.io/blog/2012/10/22/UIView-Rendering/" target="_blank" rel="external">理解UIView的绘制</a> 这篇文章中提到，<code>UIView</code> 从绘制到渲染的过程有如下几步：</p>
<blockquote>
<p>每一个 UIView 都有一个 layer，每一个 layer 都有个 content，这个 content 指向的是一块缓存，叫做 backing store。</p>
<p>UIView 的绘制和渲染是两个过程，当 UIView 被绘制时，CPU 执行drawRect，通过 context 将数据写入 backing store。</p>
<p>当 backing store 写完后，通过 render server 交给 GPU 去渲染，将backing store 中的 bitmap 数据显示在屏幕上。</p>
</blockquote>
<p>异步渲染，其实就是把<strong>绘制</strong>这个过程放到另外一个线程中去做，从而提高性能，而系统提供的文本控件 <code>UILabel</code> 绘制和渲染都是在主线程完成的，我们想要实现异步绘制，只能自定义文本控件！</p>
<p>然后我们来结合 <a href="https://github.com/ibireme/YYText" target="_blank" rel="external">YYText</a> 中的 <code>YYTextAsyncLayer</code> 类来看看是怎么实现异步绘制的。</p>
<p>首先 <code>YYTextAsyncLayer.h</code> 中：</p>
<ul>
<li><code>YYTextAsyncLayer</code> 是个 <code>CALayer</code> 的子类，他只有一个 <code>displaysAsynchronously</code> 属性来控制是否异步绘制。</li>
<li><code>YYTextAsyncLayerDelegate</code> 代理，它只返回一个 <code>YYTextAsyncLayerDisplayTask</code> 对象。</li>
<li><code>YYTextAsyncLayerDisplayTask</code> 有三个 <code>block</code>，<code>willDisplay</code> 和 <code>didDisplay</code> 分别用来处理绘制前以及绘制后的事情，并且都在主线程中；<code>display</code> 是真正绘制的方法，会根据 <code>displaysAsynchronously</code>来决定是在主线程中还是异步线程中绘制。</li>
</ul>
<p>接着 <code>YYTextAsyncLayer.m</code> 中：</p>
<p>首先是初始化：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">instancetype</span>)init &#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    <span class="keyword">static</span> <span class="built_in">CGFloat</span> scale; <span class="comment">//global</span></div><div class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</div><div class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</div><div class="line">        scale = [<span class="built_in">UIScreen</span> mainScreen].scale;</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">self</span>.contentsScale = scale;</div><div class="line">    _sentinel = [_YYTextSentinel new];</div><div class="line">    _displaysAsynchronously = <span class="literal">YES</span>;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>_YYTextSentinel</code> 类只包含一个 <code>int32_t</code> 类型的属性和<code>increase</code> 方法，它的实现是一个线程安全的自增器 <code>OSAtomicIncrement32</code> ，这个类的作用只有一个，那就是用来判断当前的绘制是否<strong>取消</strong>，具体下面再详细讲解。下面三个方法的重写都是用来标识绘制取消的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//对象释放了（绘制肯定取消）</span></div><div class="line">- (<span class="keyword">void</span>)dealloc &#123;</div><div class="line">    [_sentinel increase];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//重新绘制（都重新绘制了，上一次绘制肯定取消）</span></div><div class="line">- (<span class="keyword">void</span>)setNeedsDisplay &#123;</div><div class="line">    [<span class="keyword">self</span> _cancelAsyncDisplay];</div><div class="line">    [<span class="keyword">super</span> setNeedsDisplay];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)_cancelAsyncDisplay &#123;</div><div class="line">    [_sentinel increase];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后我们可以看到重写了 <code>display</code> 方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)display &#123;</div><div class="line">    <span class="keyword">super</span>.contents = <span class="keyword">super</span>.contents;</div><div class="line">    [<span class="keyword">self</span> _displayAsync:_displaysAsynchronously];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>绘制之前会给 <code>layer</code> 的 <code>content</code> 重新赋值，至于为什么会是 <code>super</code> 可以看看这道很有意思的<a href="https://github.com/BaiduHiDeviOS/iOS-puzzles/issues/1" target="_blank" rel="external">笔试题目</a>。</p>
<p>接着就是调用 <code>_displayAsync:</code>方法来绘制了：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">__<span class="keyword">strong</span> <span class="keyword">id</span>&lt;YYTextAsyncLayerDelegate&gt; delegate = (<span class="keyword">id</span>)<span class="keyword">self</span>.delegate;</div><div class="line">YYTextAsyncLayerDisplayTask *task = [delegate newAsyncDisplayTask];</div></pre></td></tr></table></figure>
<p>这里的 <code>self.delegate</code> 其实就是 <code>YYLabel</code>，<code>UIView</code> 其实就是 <code>CALayer</code> 的代理，我们找到 <code>YYLabel.m</code> 可以发现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">+ (Class)layerClass &#123;</div><div class="line">    <span class="keyword">return</span> [YYTextAsyncLayer <span class="keyword">class</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里重写了 <code>layerClass</code> 方法，这也是第二句代码能奏效的原因之一。<code>newAsyncDisplayTask</code> 返回一个 <code>YYTextAsyncLayerDisplayTask</code> 对象， <code>willDisplay</code>、<code>display</code> 和 <code>didDisplay</code> 三个 <code>block</code> 的具体实现也都是抛到 <code>UIView</code> 里来做，这么设计原因估计也是为了解耦。</p>
<p>我们接着看：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!task.display) &#123;</div><div class="line">        <span class="keyword">if</span> (task.willDisplay) task.willDisplay(<span class="keyword">self</span>);</div><div class="line">        <span class="keyword">self</span>.contents = <span class="literal">nil</span>;</div><div class="line">        <span class="keyword">if</span> (task.didDisplay) task.didDisplay(<span class="keyword">self</span>, <span class="literal">YES</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这边要是没实现 <code>display</code> 会清空 <code>contents</code> 并返回。</p>
<p>接下来就会根据 <code>async</code> 开关来决定是直接绘制还是异步绘制，我们直接开看执行 <code>true</code> 的部分：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (task.willDisplay) task.willDisplay(<span class="keyword">self</span>);</div><div class="line">_YYTextSentinel *sentinel = _sentinel;</div><div class="line">int32_t value = sentinel.value;</div><div class="line"><span class="built_in">BOOL</span> (^isCancelled)() = ^<span class="built_in">BOOL</span>() &#123;</div><div class="line">     <span class="keyword">return</span> value != sentinel.value;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>第一句是执行绘制前的操作，下面几句通过 <code>isCancelled</code> 这个 <code>block</code> 来判断是否<strong>取消绘制</strong>。这边有个小 <code>Tips</code>：<code>block</code> 引入变量的时候会将外界变量 <code>copy</code> 于栈中，这样即使外界变量发生改变，<code>block</code> 中的变量也不会发生改变，也就是 <code>value</code> 是取得 <code>sentinel.value</code> 变化之前的值，<code>sentinel.value</code> 值会在调用 <code>setNeedsDisplay</code>以及 <code>dealloc</code> 发生变化，这样一对比就能知道本次绘制是否取消了。</p>
<p>我们接着看：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CGSize</span> size = <span class="keyword">self</span>.bounds.size;</div><div class="line"><span class="built_in">BOOL</span> opaque = <span class="keyword">self</span>.opaque;</div><div class="line"><span class="built_in">CGFloat</span> scale = <span class="keyword">self</span>.contentsScale;</div><div class="line"><span class="built_in">CGColorRef</span> backgroundColor = (opaque &amp;&amp; <span class="keyword">self</span>.backgroundColor) ? <span class="built_in">CGColorRetain</span>(<span class="keyword">self</span>.backgroundColor) : <span class="literal">NULL</span>;</div><div class="line"><span class="keyword">if</span> (size.width &lt; <span class="number">1</span> || size.height &lt; <span class="number">1</span>) &#123;</div><div class="line">   <span class="built_in">CGImageRef</span> image = (__bridge_retained <span class="built_in">CGImageRef</span>)(<span class="keyword">self</span>.contents);</div><div class="line">   <span class="keyword">self</span>.contents = <span class="literal">nil</span>;</div><div class="line">   <span class="keyword">if</span> (image) &#123;</div><div class="line">       <span class="built_in">dispatch_async</span>(YYTextAsyncLayerGetReleaseQueue(), ^&#123;</div><div class="line">           <span class="built_in">CFRelease</span>(image);</div><div class="line">       &#125;);</div><div class="line">   &#125;</div><div class="line">       <span class="keyword">if</span> (task.didDisplay) task.didDisplay(<span class="keyword">self</span>, <span class="literal">YES</span>);</div><div class="line">       <span class="built_in">CGColorRelease</span>(backgroundColor);</div><div class="line">       <span class="keyword">return</span>;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>这段代码的目的是在绘制之前会先判断 <code>size</code> 的宽高，如果 <code>&lt; 1</code> 就没必要绘制了，做一些清理操作并返回。</p>
<p>我们再来看看 <code>YYTextAsyncLayerGetDisplayQueue</code> 这个 <code>dispatch_queue_t</code> ：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="built_in">dispatch_queue_t</span> YYTextAsyncLayerGetDisplayQueue() &#123;</div><div class="line"><span class="meta">#define MAX_QUEUE_COUNT 16</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> queueCount;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_queue_t</span> queues[MAX_QUEUE_COUNT];</div><div class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</div><div class="line">    <span class="keyword">static</span> int32_t counter = <span class="number">0</span>;</div><div class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</div><div class="line">        queueCount = (<span class="keyword">int</span>)[<span class="built_in">NSProcessInfo</span> processInfo].activeProcessorCount;</div><div class="line">        queueCount = queueCount &lt; <span class="number">1</span> ? <span class="number">1</span> : queueCount &gt; MAX_QUEUE_COUNT ? MAX_QUEUE_COUNT : queueCount;</div><div class="line">        <span class="keyword">if</span> ([<span class="built_in">UIDevice</span> currentDevice].systemVersion.floatValue &gt;= <span class="number">8.0</span>) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; queueCount; i++) &#123;</div><div class="line">                dispatch_queue_attr_t attr = dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_SERIAL, QOS_CLASS_USER_INITIATED, <span class="number">0</span>);</div><div class="line">                queues[i] = dispatch_queue_create(<span class="string">"com.ibireme.text.render"</span>, attr);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; queueCount; i++) &#123;</div><div class="line">                queues[i] = dispatch_queue_create(<span class="string">"com.ibireme.text.render"</span>, DISPATCH_QUEUE_SERIAL);</div><div class="line">                dispatch_set_target_queue(queues[i], dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    uint32_t cur = (uint32_t)OSAtomicIncrement32(&amp;counter);</div><div class="line">    <span class="keyword">return</span> queues[(cur) % queueCount];</div><div class="line"><span class="meta">#undef MAX_QUEUE_COUNT</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个队列是自己创建的，在预设了一个队列最大值之后，通过获取运行该进程的系统处于激活状态的处理器数量来创建队列，使得绘制的效率达到最高。</p>
<p>接下来会先判断是否 <code>isCancelled()</code>，<code>true</code> 就直接返回：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (isCancelled()) &#123;</div><div class="line">    <span class="built_in">CGColorRelease</span>(backgroundColor);</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接着创建图形上下文并取出来：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(size, opaque, scale);</div><div class="line"><span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();</div></pre></td></tr></table></figure>
<p>接着是填充背景色：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (opaque) &#123;</div><div class="line">    <span class="built_in">CGContextSaveGState</span>(context); &#123;</div><div class="line">    <span class="keyword">if</span> (!backgroundColor || <span class="built_in">CGColorGetAlpha</span>(backgroundColor) &lt; <span class="number">1</span>) &#123;</div><div class="line">       <span class="built_in">CGContextSetFillColorWithColor</span>(context, [<span class="built_in">UIColor</span> whiteColor].CGColor);</div><div class="line">       <span class="built_in">CGContextAddRect</span>(context, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, size.width * scale, size.height * scale));</div><div class="line">       <span class="built_in">CGContextFillPath</span>(context);</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">if</span> (backgroundColor) &#123;</div><div class="line">         <span class="built_in">CGContextSetFillColorWithColor</span>(context, backgroundColor);</div><div class="line">         <span class="built_in">CGContextAddRect</span>(context, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, size.width * scale, size.height * scale));</div><div class="line">         <span class="built_in">CGContextFillPath</span>(context);</div><div class="line">     &#125;</div><div class="line">    &#125; <span class="built_in">CGContextRestoreGState</span>(context);</div><div class="line">  <span class="built_in">CGColorRelease</span>(backgroundColor);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码一般走不进来，因为正常 <code>opaque</code> 都是 <code>NO</code>。<code>CGContextSaveGState</code> 和 <code>CGContextRestoreGState</code> 一般成对出现，包在它们中间的代码在执行完 <code>CGContextRestoreGState</code> 后会回退到操作之前的状态，因为 <code>context</code> 只有一份儿，防止多出操作上下文出问题。</p>
<p>接着就是执行 <code>display</code> 这个 <code>block</code>，会传 <code>context</code>、<code>size</code>以及 <code>isCancelled</code> 三个参数：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">task.display(context, size, isCancelled);</div></pre></td></tr></table></figure>
<p>最后绘制完成后会取出 <code>image</code>，并在主线程赋值给 <code>self.contents</code>，大概这样：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UIImage</span> *image = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</div><div class="line"><span class="built_in">UIGraphicsEndImageContext</span>();</div><div class="line"></div><div class="line"><span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">   <span class="keyword">if</span> (isCancelled()) &#123;</div><div class="line">       <span class="keyword">if</span> (task.didDisplay) task.didDisplay(<span class="keyword">self</span>, <span class="literal">NO</span>);</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       <span class="keyword">self</span>.contents = (__bridge <span class="keyword">id</span>)(image.CGImage);</div><div class="line">       <span class="keyword">if</span> (task.didDisplay) task.didDisplay(<span class="keyword">self</span>, <span class="literal">YES</span>);</div><div class="line">   &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>绘制 <code>UIView</code> 的最快的办法就是把它当做一个 <code>imageView</code>，我想这也是 <code>YYText</code> 为什么要这么绘制的原因 ：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(<span class="keyword">self</span>.bounds.size, <span class="keyword">self</span>.opaque, <span class="keyword">self</span>.contentsScale);</div><div class="line"><span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();</div><div class="line">	</div><div class="line">					<span class="comment">/** display */</span></div><div class="line"></div><div class="line"><span class="built_in">UIImage</span> *image = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</div><div class="line"><span class="built_in">UIGraphicsEndImageContext</span>();</div><div class="line"><span class="keyword">self</span>.contents = (__bridge <span class="keyword">id</span>)(image.CGImage);</div></pre></td></tr></table></figure>
<h4 id="YYLabel-功能提取"><a href="#YYLabel-功能提取" class="headerlink" title="YYLabel 功能提取"></a>YYLabel 功能提取</h4><p><code>YYText</code> 中的 <code>YYLabel</code> 是用 <code>CoreText</code> 排版的自定义文本控件，因为功能太丰富，导致整个库代码将近两万行，而我的需求只需要些简单的功能，所以自己抽离了些功能，整合了个阉割版的支持异步绘制的文本控件 <a href="https://github.com/ifelseboyxx/AsynDisplayLabel" target="_blank" rel="external">AsynDisplayLabel</a>，有和我需求相同的自取。</p>
<h4 id="To-do"><a href="#To-do" class="headerlink" title="To do"></a>To do</h4><p>弄完异步绘制后，发现列表流畅性又提升了不少，但是还有优化的余地：<code>YYLabel</code> 可以支持直接取用之前缓存好的 <code>CoreText</code> 排版，而我这边因为图方便，用的是 <code>TextKit</code> 的方法计算的宽高，并且阉割版的 <code>YYLabel</code> 不支持直接取用 <code>CoreText</code> 排版，导致绘制的时候还需要计算一遍 <code>CoreText</code> 排版，相信优化下这部分流畅性还能提升！</p>
</div></article></div></main><footer><div class="paginator"><a href="/2017/04/11/MultipleDelegate/" class="prev">上一篇</a><a href="/2017/02/23/Masonry-Analysis/" class="next">下一篇</a></div><div class="copyright"><p>© 2016 - 2017 <a href="http://blog.ifelseboyxx.com/">ifelseboyxx</a> | Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>
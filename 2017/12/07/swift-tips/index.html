<!DOCTYPE html>
<html lang="zh-cn">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    
        <meta name="description" content="以下内容均是笔者学习过程中收集的知识点，顺序比较跳跃，初衷是为了方便查阅，顺便加深记忆。内容会不断更新，如果有什么问题或者有好的 Swift 方面的语法糖或者知识点也可以提出来，我会挑选斟酌后收录，欢迎大家关注～
环境：

Swift 4.0Xcode 9.1

最近更新：2017.12.13

优">
    

    <!--Author-->
    
        <meta name="author" content="ifelseboyxx">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="Swift 知识小集"/>
    

    <!--Open Graph Description-->
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="ifelseboyxx&#39;s Blog"/>

    <!--Type page-->
    
        <meta property="og:type" content="article" />
    

    <!--Page Cover-->
    

        <meta name="twitter:card" content="summary" />
    

    <!-- Title -->
    
    <title>Swift 知识小集 - ifelseboyxx&#39;s Blog</title>

    <!-- Bootstrap Core CSS -->
    <link href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap.css" rel="stylesheet">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Custom Fonts -->
    <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href="//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet" type="text/css">
    <link href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="//cdn.bootcss.com/html5shiv/3.7.3/html5shiv.min.js"></script>
    <script src="//cdn.bootcss.com/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdn.bootcss.com/featherlight/1.7.1/featherlight.min.css" type="text/css" rel="stylesheet">

    <!-- Google Analytics -->
    


    <!-- favicon -->
    
    <link rel="icon" href="/img/red.png">
    
	
</head>


<body>

    <!-- Menu -->
    
        <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">ifelseboyxx {"🤢"}</a>

        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                <li>
                    
                        <li class="previous disabled">
                            <a href="#">&larr;  Prev</a>
                        </li>
                    
                </li>
                <li>
                    
                        <li class="next" title="Method Swizzling 实战：Hook 系统代理方法">
                            <a href="/2017/11/30/hook_system_delegate/">Next  &rarr;</a>
                        </li>
                    
                </li>

                
                    <li>
                        <a href="/">
                            
                                Home
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/archives">
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="https://github.com/ifelseboyxx">
                            
                                GitHub
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="https://juejin.im/user/5a421a5ef265da4320038046">
                            
                                掘金
                            
                        </a>
                    </li>
                
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
    

    <!-- Main Content -->
    <!-- Page Header -->
<!-- Set your background image for this header in your post front-matter: cover -->


<header class="intro-header">
    <div class="container">
    </div>
</header>


<div class="container">
    <div class="row">
        <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
            <div class="post-preview">
                <!-- Title -->
                <a href="/2017/12/07/swift-tips/">
                    <h2 class="post-title">
                        Swift 知识小集
                    </h2>
                </a>

                <!-- Tags -->
                

                <p class="post-meta">
                    <!-- Date and Author -->
                    
                    2017-12-07
                </p>
            </div>
            <hr>
        </div>
    </div>
</div>


<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Gallery -->
            

            <!-- Post Main Content -->
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <p>以下内容均是笔者学习过程中<strong>收集</strong>的知识点，顺序比较跳跃，初衷是为了方便查阅，顺便加深记忆。<strong>内容会不断更新</strong>，如果有什么问题或者有好的 Swift 方面的语法糖或者知识点也可以提出来，我会挑选斟酌后收录，欢迎大家关注～</p>
<p><strong>环境：</strong></p>
<blockquote>
<p>Swift 4.0<br>Xcode 9.1</p>
</blockquote>
<p><strong>最近更新：2017.12.13</strong></p>
<blockquote>
<p><a href="#1.3.5">优雅的定义通知名称</a></p>
</blockquote>
<p><strong>更新：2017.12.11</strong></p>
<blockquote>
<p><a href="#1.3.2">作用域：do 语句块</a><br><a href="#1.3.3">倒序 reversed()</a><br><a href="#1.3.4">标签语句：指定跳出某个条件语句</a></p>
</blockquote>
<p><strong>更新：2017.12.08</strong></p>
<blockquote>
<p><a href="#1.2.9">Swift 中的 “@synchronized”</a><br><a href="#1.3.0">自定义日志输出</a><br><a href="#1.3.1">Swift 中的 “readonly”</a></p>
</blockquote>
<p><strong>目录：</strong></p>
<blockquote>
<p><a href="#1.1.1">Associated Object</a><br><a href="#1.1.2">Delegate 声明为 weak</a><br><a href="#1.1.3">可选协议和协议扩展</a><br><a href="#1.1.4">单例</a><br><a href="#1.1.5">输出格式化</a><br><a href="#1.1.6">Selector</a><br><a href="#1.1.7">将 protocol 的方法声明为 mutating</a><br><a href="#1.1.8">数组遍历 enumerate</a><br><a href="#1.1.9">输入输出参数 inout</a><br><a href="#1.2.0">Default 参数</a><br><a href="#1.2.1">延迟加载 lazy</a><br><a href="#1.2.2">编译标记</a><br><a href="#1.2.3">换行符</a><br><a href="#1.2.4">字符串切割 split</a><br><a href="#1.2.5">KVC</a><br><a href="#1.2.6">Swift 中值类型和引用类型注意点</a><br><a href="#1.2.7">KVO</a><br><a href="#1.2.8">Swift UIButton 状态的叠加</a><br><a href="#1.2.9">Swift 中的 “@synchronized”</a><br><a href="#1.3.0">自定义日志输出</a><br><a href="#1.3.1">Swift 中的 “readonly”</a><br><a href="#1.3.2">作用域：do 语句块</a><br><a href="#1.3.3">倒序 reversed()</a><br><a href="#1.3.4">标签语句：指定跳出某个条件语句</a><br><a href="#1.3.5">优雅的定义通知名称</a></p>
</blockquote>
<h2 id="1.1.1"> Associated Object </h2>

<p>Objective-C 的 runtime 里的 Associated Object 允许我们在使用 Category 扩展现有的类的功能的时候，直接添加实例变量。在 Swift 中 extension 不能添加<strong>存储属性</strong>，我们可以利用 Associated Object 来实现，比如下面的 <code>title</code> 「实际上」是一个存储属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// MyClass.swift</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">// MyClassExtension.swift</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">var</span> key: <span class="type">Void</span>?</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">MyClass</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> title: <span class="type">String</span>? &#123;</div><div class="line">        <span class="keyword">get</span> &#123;</div><div class="line">            <span class="keyword">return</span> swift_getAssociatedObject(<span class="keyword">self</span>, &amp;key) <span class="keyword">as</span>? <span class="type">String</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">set</span> &#123;</div><div class="line">            swift_setAssociatedObject(<span class="keyword">self</span>,</div><div class="line">                &amp;key, newValue,</div><div class="line">                .swift_ASSOCIATION_RETAIN_NONATOMIC)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 测试</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">printTitle</span><span class="params">(<span class="number">_</span> input: MyClass)</span></span> &#123;</div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> title = input.title &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"Title: \(title)"</span>)</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"没有设置"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> a = <span class="type">MyClass</span>()</div><div class="line">printTitle(a)</div><div class="line">a.title = <span class="string">"Swifter.tips"</span></div><div class="line">printTitle(a)</div><div class="line"></div><div class="line"><span class="comment">// 输出：</span></div><div class="line"><span class="comment">// 没有设置</span></div><div class="line"><span class="comment">// Title: Swifter.tips”</span></div></pre></td></tr></table></figure>
<h2 id="1.1.2"> Delegate 声明为 weak </h2>

<p>Swift 中 Delegate 需要被声明成 <code>weak</code>，来避免访问到已被回收的内存而导致崩溃，如果我们像下面这样，是编译不过的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">MyClassDelegate</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">method</span><span class="params">()</span></span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</div><div class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> delegate: <span class="type">MyClassDelegate</span>?</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>, <span class="title">MyClassDelegate</span> </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    <span class="keyword">var</span> someInstance: <span class="type">MyClass</span>!</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.viewDidLoad()</div><div class="line"></div><div class="line">        someInstance = <span class="type">MyClass</span>()</div><div class="line">        someInstance.delegate = <span class="keyword">self</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">method</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"Do something"</span>)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 编译失败</span></div><div class="line"><span class="comment">// 'weak' may only be applied to class and class-bound protocol types, not 'MyClassDelegate'</span></div></pre></td></tr></table></figure>
<p>这是因为 Swift 的 protocol 是可以被除了 class 以外的其他类型遵守的，而对于像 <code>struct</code> 或是 <code>enum</code> 这样的类型，本身就不通过引用计数来管理内存，所以也不可能用 <code>weak</code> 这样的 ARC 的概念来进行修饰。</p>
<p>想要在 Swift 中使用 weak delegate，我们就需要将 protocol 限制在 class 内：</p>
<ul>
<li>一种做法是将 protocol 声明为 Objective-C 的，这可以通过在 protocol 前面加上 <code>@objc</code> 关键字来达到，Objective-C 的 protocol 都只有类能实现，因此使用 weak 来修饰就合理了：</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@objc</span> <span class="class"><span class="keyword">protocol</span> <span class="title">MyClassDelegate</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">method</span><span class="params">()</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>另一种<strong>可能更好</strong>的办法是在 protocol 声明的名字后面加上 <code>class</code>，这可以为编译器显式地指明这个 protocol 只能由 <code>class</code> 来实现，避免了过多的不必要的 Objective-C 兼容：</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">MyClassDelegate</span>: <span class="title">class</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">method</span><span class="params">()</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="1.1.3"> 可选协议和协议扩展 </h2>

<p>Objective-C 中的 protocol 里存在 <code>@optional</code> 关键字，被这个关键字修饰的方法并非必须要被实现，原生的 Swift protocol 里没有可选项，所有定义的方法都是必须实现的，如果不是实现是无法编译的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>,<span class="title">MyProtocol</span> </span>&#123; &#125;</div><div class="line"></div><div class="line"><span class="comment">// 编译失败</span></div><div class="line"><span class="comment">// Type 'ViewController' does not conform to protocol 'MyProtocol'</span></div></pre></td></tr></table></figure>
<p>如果我们想要像 Objective-C 里那样定义可选的协议方法，就需要将协议本身和可选方法都定义为 Objective-C 的，也即在 protocol 定义之前加上 <code>@objc</code>，方法之前加上 <code>@objc optional</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@objc</span> <span class="class"><span class="keyword">protocol</span> <span class="title">MyProtocol</span> </span>&#123;</div><div class="line">    <span class="meta">@objc</span> <span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">myMethod</span><span class="params">()</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另外，对于所有的声明，它们的前缀修饰是完全分开的，<strong>也就是说你不能像是在 Objective-C 里那样用一个 <code>@optional</code> 指定接下来的若干个方法都是可选的了，</strong>必须对每一个可选方法添加前缀，对于没有前缀的方法来说，它们是默认必须实现的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@objc</span> <span class="class"><span class="keyword">protocol</span> <span class="title">MyProtocol</span> </span>&#123;</div><div class="line">    <span class="meta">@objc</span> <span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">optionalMethod</span><span class="params">()</span></span>        <span class="comment">// 可选</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">necessaryMethod</span><span class="params">()</span></span>                      <span class="comment">// 必须</span></div><div class="line">    <span class="meta">@objc</span> <span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">anotherOptionalMethod</span><span class="params">()</span></span> <span class="comment">// 可选</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>一个不可避免的限制是</strong>，使用 <code>@objc</code> 修饰的 protocol 就只能被 <code>class</code> 实现了，也就是说，对于 <code>struct</code> 和 <code>enum</code> 类型，我们是无法令它们所实现的协议中含有可选方法或者属性的。另外，实现它的 <code>class</code> 中的方法还必须也被标注为 <code>@objc</code>，或者整个类就是继承自 <code>NSObject</code>。对于这种问题，在 Swift 2.0 中，我们有了另一种选择，那就是使用 <strong>protocol extension</strong>。我们可以在声明一个 protocol 之后再用 extension 的方式给出部分方法<strong>默认的实现</strong>，这样这些方法在实际的类中就是可选实现的了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">MyProtocol</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">optionalMethod</span><span class="params">()</span></span>        <span class="comment">// 可选</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">necessaryMethod</span><span class="params">()</span></span>       <span class="comment">// 必须</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">anotherOptionalMethod</span><span class="params">()</span></span> <span class="comment">// 可选</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">MyProtocol</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">//默认的可选实现</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">optionalMethod</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"optionalMethod"</span>)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//默认的可选实现</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">anotherOptionalMethod</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"anotherOptionalMethod"</span>)</div><div class="line">    &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>,<span class="title">MyProtocol</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">// 必须的实现</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">necessaryMethod</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"necessaryMethod"</span>)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.viewDidLoad()</div><div class="line">        </div><div class="line">        <span class="keyword">self</span>.optionalMethod();</div><div class="line">        <span class="keyword">self</span>.necessaryMethod();</div><div class="line">        <span class="keyword">self</span>.anotherOptionalMethod();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 输出：</span></div><div class="line"><span class="comment">// optionalMethod</span></div><div class="line"><span class="comment">// necessaryMethod</span></div><div class="line"><span class="comment">// necessaryMethod</span></div></pre></td></tr></table></figure>
<h2 id="1.1.4"> 单例 </h2>

<p>Swift 中的单例非常简单，Swift 1.2 以及之后：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>  </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">let</span> sharedInstance = <span class="type">Singleton</span>()</div><div class="line">    <span class="keyword">private</span> <span class="keyword">init</span>() &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种写法不但是线程安全的，也是懒加载的，<code>let</code> 定义的属性本身就是线程安全的，同时 <code>static</code> 定义的是一个 class constant，拥有全局作用域和懒加载特性。</p>
<p>另外，这个类型中加入了一个私有的初始化方法，来覆盖默认的公开初始化方法，这让项目中的其他地方不能够通过 init 来生成自己的 <code>Singleton</code> 实例，也保证了类型单例的唯一性。如果你需要的是类似 default 的形式的单例 (也就是说这个类的使用者可以创建自己的实例) 的话，可以去掉这个私有的 <code>init</code> 方法。</p>
<h2 id="1.1.5"> 输出格式化 </h2>

<p>在 Objective-C 中的 <code>%@</code> 这样的格式在指定的位置设定占位符，然后通过参数的方式将实际要输出的内容补充完整。例如 Objective-C 中常用的向控制台输出的 <code>NSLog</code> 方法就使用了这种格式化方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">float a = <span class="number">1.234567</span>;</div><div class="line"><span class="type">NSString</span> *b = @<span class="string">"Helllo"</span>;</div><div class="line"><span class="type">NSLog</span>(@<span class="string">"float：%.2f  str：%p"</span>,a,b);</div><div class="line"></div><div class="line"><span class="comment">// 输出：</span></div><div class="line"><span class="comment">// float：1.23  str：0x1024a1078</span></div></pre></td></tr></table></figure>
<p>对应 Swift 中我们可以这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a = <span class="number">1.234567</span></div><div class="line"><span class="keyword">let</span> b = <span class="string">"Helllo"</span></div><div class="line"><span class="keyword">let</span> <span class="built_in">c</span> = <span class="type">String</span>(format:<span class="string">"float：%.2f str：%p"</span>,a,b)</div><div class="line"><span class="built_in">print</span>(<span class="built_in">c</span>)</div><div class="line"></div><div class="line"><span class="comment">// 输出：</span></div><div class="line"><span class="comment">// float：1.23 str：0x604000249e10</span></div></pre></td></tr></table></figure>
<h2 id="1.1.6"> Selector </h2>

<p><code>@selector</code> 是 Objective-C 时代的一个关键字，它可以将一个方法转换并赋值给一个 SEL 类型，它的表现很类似一个动态的函数指针。在 Swift 中没有 <code>@selector</code> 了，取而代之，从 Swift 2.2 开始我们使用 <code>#selector</code> 来从暴露给 Objective-C 的代码中获取一个 <code>selector</code>，并且因为 <code>selector</code> 是 Objective-C runtime 的概念，在 Swift 4 中，默认情况下所有的 Swift 方法在 Objective-C 中都是不可见的，所以你需要在这类方法前面加上 <code>@objc</code> 关键字，将这个方法暴露给 Objective-C，才能进行使用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> btn = <span class="type">UIButton</span>.<span class="keyword">init</span>(type: .system)</div><div class="line">btn.backgroundColor = <span class="type">UIColor</span>.red</div><div class="line">btn.frame = <span class="type">CGRect</span>(x: <span class="number">100</span>, y: <span class="number">100</span>, width: <span class="number">150</span>, height: <span class="number">40</span>)</div><div class="line">btn.setTitle(<span class="string">"Button"</span>, <span class="keyword">for</span>: .normal)</div><div class="line"><span class="comment">//无参数</span></div><div class="line">btn.addTarget(<span class="keyword">self</span>, action: #selector(btnClick), <span class="keyword">for</span>: .touchUpInside)</div><div class="line">view.addSubview(btn)</div><div class="line"></div><div class="line"><span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">btnClick</span><span class="params">()</span></span>  &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"button click !"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line"><span class="comment">//有参数</span></div><div class="line">btn.addTarget(<span class="keyword">self</span>, action: #selector(btnClick(<span class="number">_</span> :)), <span class="keyword">for</span>: .touchUpInside)</div><div class="line">...</div><div class="line"></div><div class="line"><span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">btnClick</span><span class="params">(<span class="number">_</span> button: UIButton)</span></span>  &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"button click !"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="1.1.7"> 将 protocol 的方法声明为 mutating </h2>

<p>Swift 的 protocol 不仅可以被 class 类型实现，也适用于 <code>struct</code> 和 <code>enum</code>，因为这个原因，我们在写给别人用的协议时需要多考虑是否使用 <code>mutating</code> 来修饰方法。Swift 的 <code>mutating</code> 关键字修饰方法是为了能在该方法中修改 <code>struct</code> 或是 <code>enum</code> 的变量，所以如果你没在协议方法里写 <code>mutating</code> 的话，别人如果用 <code>struct</code> 或者 <code>enum</code> 来实现这个协议的话，就不能在方法里改变自己的变量了，比如下面的代码是编译不过的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Vehicle</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">changeColor</span><span class="params">()</span></span></div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyCar</span>: <span class="title">Vehicle</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">var</span> color = <span class="string">"blue"</span></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">changeColor</span><span class="params">()</span></span> &#123;</div><div class="line">        color = <span class="string">"red"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 编译失败</span></div><div class="line"><span class="comment">// Cannot assign to property: 'self' is immutable</span></div></pre></td></tr></table></figure>
<p>我们应该加上 <code>mutating</code> 关键字：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Vehicle</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">changeColor</span><span class="params">()</span></span></div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyCar</span>: <span class="title">Vehicle</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">var</span> color = <span class="string">"blue"</span></div><div class="line">    </div><div class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">changeColor</span><span class="params">()</span></span> &#123;</div><div class="line">        color = <span class="string">"red"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">super</span>.viewDidLoad()</div><div class="line"></div><div class="line">    <span class="keyword">var</span> car = <span class="type">MyCar</span>()</div><div class="line">    <span class="built_in">print</span>(car.color)</div><div class="line">    car.changeColor()</div><div class="line">    <span class="built_in">print</span>(car.color)    </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 输出：</span></div><div class="line"><span class="comment">// blue</span></div><div class="line"><span class="comment">// 输出：</span></div><div class="line"><span class="comment">// red</span></div></pre></td></tr></table></figure>
<h2 id="1.1.8"> 数组遍历 enumerate </h2>

<p>使用 NSArray 时一个很常遇见的的需求是在枚举数组内元素的同时也想使用对应的<strong>下标索引</strong>，在 Objective-C 中最方便的方式是使用 NSArray 的 <code>enumerateObjectsUsingBlock:</code> ，在 Swift 中存在一个效率，安全性和可读性都很好的替代，那就是快速枚举某个数组的<code>EnumerateGenerator</code>，它的元素是同时包含了元素下标索引以及元素本身的多元组：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> arr = [<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>,<span class="string">"e"</span>]</div><div class="line"><span class="keyword">for</span> (idx, str) <span class="keyword">in</span> arr.enumerated() &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"idx: \(idx) str: \(str)"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 输出：</span></div><div class="line">idx: <span class="number">0</span> str: a</div><div class="line">idx: <span class="number">1</span> str: b</div><div class="line">idx: <span class="number">2</span> str: <span class="built_in">c</span></div><div class="line">idx: <span class="number">3</span> str: d</div><div class="line">idx: <span class="number">4</span> str: e</div></pre></td></tr></table></figure>
<h2 id="1.1.9"> 输入输出参数 inout </h2>

<p>函数参数默认是<strong>常量</strong>，如果试图在函数体中更改参数值将会导致<strong>编译错误</strong>，比如下面的例子中尝试着交换值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapTwoInts</span><span class="params">(<span class="number">_</span> a: Int, <span class="number">_</span> b: Int)</span></span> &#123;</div><div class="line">    <span class="keyword">let</span> temporaryA = a</div><div class="line">    a = b</div><div class="line">    b = temporaryA</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 编译失败</span></div><div class="line"><span class="comment">// Cannot assign to value: 'a' is a 'let' constant</span></div><div class="line"><span class="comment">// Cannot assign to value: 'b' is a 'let' constant</span></div></pre></td></tr></table></figure>
<p>如果想要一个函数可以修改参数的值，并且想要在这些修改在函数调用结束后仍然存在，那么就应该把这个参数定义为输入输出参数（In-Out Parameters）：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapTwoInts</span><span class="params">(<span class="number">_</span> a: <span class="keyword">inout</span> Int, <span class="number">_</span> b: <span class="keyword">inout</span> Int)</span></span> &#123;</div><div class="line">    <span class="keyword">let</span> temporaryA = a</div><div class="line">    a = b</div><div class="line">    b = temporaryA</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="1.2.0"> Default 参数 </h2>

<p>Swift 的方法是支持默认参数的，也就是说在声明方法时，可以给某个参数指定一个默认使用的值。在调用该方法时要是传入了这个参数，则使用传入的值，如果缺少这个输入参数，那么直接使用设定的默认值进行调用。和其他很多语言的默认参数相比较，Swift 中的默认参数限制更少，并没有所谓 <strong>“默认参数之后不能再出现无默认值的参数”</strong>这样的规则，举个例子，下面两种方法的声明在 Swift 里都是合法可用的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello1</span><span class="params">(str1: String = <span class="string">"Hello"</span>, str2: String, str3: String)</span></span> &#123;</div><div class="line">    <span class="built_in">print</span>(str1 + str2 + str3)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello2</span><span class="params">(str1: String, str2: String, str3: String = <span class="string">"World"</span>)</span></span> &#123;</div><div class="line">    <span class="built_in">print</span>(str1 + str2 + str3)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sayHello1(str2: <span class="string">" "</span>, str3: <span class="string">"World"</span>)</div><div class="line">sayHello2(str1: <span class="string">"Hello"</span>, str2: <span class="string">" "</span>)</div><div class="line"></div><div class="line"><span class="comment">//输出都是 Hello World</span></div></pre></td></tr></table></figure>
<h2 id="1.2.1"> 延迟加载 lazy </h2>

<p>延时加载或者说延时初始化是很常用的优化方法，在构建和生成新的对象的时候，内存分配会在运行时耗费不少时间，<strong>如果有一些对象的属性和内容非常复杂的话，这个时间更是不可忽略</strong>。另外，有些情况下我们并不会立即用到一个对象的所有属性，而默认情况下初始化时，<strong>那些在特定环境下不被使用的存储属性，也一样要被初始化和赋值</strong>，也是一种浪费。在 Objective-C 中，一个延迟加载一般是这样的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ClassA.h</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *testString;</div><div class="line"></div><div class="line"><span class="comment">// ClassA.m</span></div><div class="line">- (<span class="built_in">NSString</span> *)testString &#123;</div><div class="line">     <span class="keyword">if</span> (!_testString) &#123;</div><div class="line">         _testString = <span class="string">@"Hello"</span>;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"只在首次访问输出"</span>);</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> _testString;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对应在 Swift 中，使用 <code>lazy</code> 作为属性修饰符时，只能声明属性是<strong>变量</strong>，且我们需要显式地指定<strong>属性类型</strong>，否则会编译错误：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> </span>&#123;</div><div class="line">    <span class="built_in">lazy</span> <span class="keyword">let</span> str: <span class="type">String</span> = &#123;</div><div class="line">        <span class="keyword">let</span> str = <span class="string">"Hello"</span></div><div class="line">        <span class="built_in">print</span>(<span class="string">"只在首次访问输出"</span>)</div><div class="line">        <span class="keyword">return</span> str</div><div class="line">    &#125;()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 编译失败</span></div><div class="line"><span class="comment">// 'lazy' cannot be used on a let</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> </span>&#123;</div><div class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> str = &#123;</div><div class="line">        <span class="keyword">let</span> str = <span class="string">"Hello"</span></div><div class="line">        <span class="built_in">print</span>(<span class="string">"只在首次访问输出"</span>)</div><div class="line">        <span class="keyword">return</span> str</div><div class="line">    &#125;()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 编译失败</span></div><div class="line"><span class="comment">// Unable to infer complex closure return type</span></div></pre></td></tr></table></figure>
<p>我们应该声明为 <code>var</code> 并指定好类型：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> </span>&#123;</div><div class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> str: <span class="type">String</span> = &#123;</div><div class="line">        <span class="keyword">let</span> str = <span class="string">"Hello"</span></div><div class="line">        <span class="built_in">print</span>(<span class="string">"只在首次访问输出"</span>)</div><div class="line">        <span class="keyword">return</span> str</div><div class="line">    &#125;()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">super</span>.viewDidLoad()</div><div class="line"></div><div class="line">    <span class="keyword">let</span> ca = <span class="type">ClassA</span>()</div><div class="line">    <span class="built_in">print</span>(ca.str)</div><div class="line">    <span class="built_in">print</span>(ca.str)</div><div class="line">    <span class="built_in">print</span>(ca.str)   </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 输出：</span></div><div class="line"><span class="comment">// 只在首次访问输出</span></div><div class="line"><span class="comment">// Hello</span></div><div class="line"><span class="comment">// Hello</span></div><div class="line"><span class="comment">// Hello</span></div></pre></td></tr></table></figure>
<p>如果不需要做什么额外工作的话，也可以对这个 <code>lazy</code> 的属性直接写赋值语句：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">lazy</span> <span class="keyword">var</span> str: <span class="type">String</span> = <span class="string">"Hello"</span></div></pre></td></tr></table></figure>
<p>我们还可以利用 <code>lazy</code> 配合像 <code>map</code> 或是 <code>filter</code> 这类接受闭包并进行运行的方法一起，<strong>让整个行为变成延时进行的</strong>。在某些情况下这么做也对性能会有不小的帮助。例如，直接使用 map 时：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> data = <span class="number">1</span>...<span class="number">3</span></div><div class="line"><span class="keyword">let</span> result = data.<span class="built_in">map</span> &#123;</div><div class="line">    (i: <span class="type">Int</span>) -&gt; <span class="type">Int</span> <span class="keyword">in</span></div><div class="line">    <span class="built_in">print</span>(<span class="string">"正在处理 \(i)"</span>)</div><div class="line">    <span class="keyword">return</span> i * <span class="number">2</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">print</span>(<span class="string">"准备访问结果"</span>)</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> result &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"操作后结果为 \(i)"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">print</span>(<span class="string">"操作完毕"</span>)</div><div class="line"></div><div class="line"><span class="comment">// 输出：</span></div><div class="line"><span class="comment">// 正在处理 1</span></div><div class="line"><span class="comment">// 正在处理 2</span></div><div class="line"><span class="comment">// 正在处理 3</span></div><div class="line"><span class="comment">// 准备访问结果</span></div><div class="line"><span class="comment">// 操作后结果为 2</span></div><div class="line"><span class="comment">// 操作后结果为 4</span></div><div class="line"><span class="comment">// 操作后结果为 6</span></div><div class="line"><span class="comment">// 操作完毕</span></div></pre></td></tr></table></figure>
<p>而如果我们先进行一次 <code>lazy</code> 操作的话，我们就能得到延时运行版本的容器：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> data = <span class="number">1</span>...<span class="number">3</span></div><div class="line"><span class="keyword">let</span> result = data.<span class="built_in">lazy</span>.<span class="built_in">map</span> &#123;</div><div class="line">    (i: <span class="type">Int</span>) -&gt; <span class="type">Int</span> <span class="keyword">in</span></div><div class="line">    <span class="built_in">print</span>(<span class="string">"正在处理 \(i)"</span>)</div><div class="line">    <span class="keyword">return</span> i * <span class="number">2</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">print</span>(<span class="string">"准备访问结果"</span>)</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> result &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"操作后结果为 \(i)"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">print</span>(<span class="string">"操作完毕"</span>)</div><div class="line"></div><div class="line"><span class="comment">// 准备访问结果</span></div><div class="line"><span class="comment">// 正在处理 1</span></div><div class="line"><span class="comment">// 操作后结果为 2</span></div><div class="line"><span class="comment">// 正在处理 2</span></div><div class="line"><span class="comment">// 操作后结果为 4</span></div><div class="line"><span class="comment">// 正在处理 3</span></div><div class="line"><span class="comment">// 操作后结果为 6</span></div><div class="line"><span class="comment">// 操作完毕</span></div></pre></td></tr></table></figure>
<p>对于那些不需要完全运行，可能提前退出的情况，使用 lazy 来进行性能优化效果会非常有效。</p>
<h2 id="1.2.2"> 编译标记 </h2>

<p>在 Objective-C 中，我们经常在代码中插入 <code>#param</code> 符号来标记代码的区间，这样在 Xcode 的导航栏中我们就可以看到组织分块后的方法列表。在 Swift 中我们可以用 <code>MARK:</code> 来代替：</p>
<p><img src="http://p0kmbfoc8.bkt.clouddn.com/Snip20171207_3.png" alt=""></p>
<p>在 Objective-C 中还有一个很常用的编译标记，那就是 <code>#warning</code>，一个 <code>#warning</code> 标记可以在 Xcode 的代码编辑器中显示为明显的黄色警告条，非常适合用来提示代码的维护者和使用者需要对某些东西加以关注。在 Swift 中我们可以用 <code>FIXME:</code> 和 <code>TODO:</code> 配合 <code>shell</code> 来代替：</p>
<p><img src="http://p0kmbfoc8.bkt.clouddn.com/Snip20171207_8.png" alt=""></p>
<p>脚本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">TAGS=&quot;TODO:|FIXME:&quot;</div><div class="line">echo &quot;searching $&#123;SRCROOT&#125; for $&#123;TAGS&#125;&quot;</div><div class="line">find &quot;$&#123;SRCROOT&#125;&quot; \( -name &quot;*.swift&quot; \) -print0 | xargs -0 egrep --with-filename --line-number --only-matching &quot;($TAGS).*\$&quot; | perl -p -e &quot;s/($TAGS)/ warning: \$1/&quot;</div></pre></td></tr></table></figure>
<p>效果：</p>
<p><img src="http://p0kmbfoc8.bkt.clouddn.com/Snip20171207_7.png" alt=""><br><img src="http://p0kmbfoc8.bkt.clouddn.com/Snip20171207_6.png" alt=""></p>
<h2 id="1.2.3"> 换行符 </h2>

<p>在 Swift 3 中，需要换行时是需要 <code>\n</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> str = <span class="string">"xxxx\nxxx"</span></div><div class="line"></div><div class="line"><span class="comment">// 输出：</span></div><div class="line"><span class="comment">// xxxx</span></div><div class="line"><span class="comment">// xxx</span></div></pre></td></tr></table></figure>
<p>在 swift 4 中，我们可以使用 <code>&quot;&quot;&quot;</code>：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">let jsonStr = """</div><div class="line">        &#123;</div><div class="line">            "id": 123455,</div><div class="line">            "nickname": "xxxx",</div><div class="line">            "isMale": true,</div><div class="line">            "birthday": "2000年3月24日",</div><div class="line">            "personalURL": "https://xxxxxx.github.io"</div><div class="line">        &#125;</div><div class="line">        """</div><div class="line">          </div><div class="line">// 输出：</div><div class="line">&#123;</div><div class="line">    "id": 123455,</div><div class="line">    "nickname": "xxxx",</div><div class="line">    "isMale": true,</div><div class="line">    "birthday": "2000年3月24日",</div><div class="line">    "personalURL": "https://xxxxxx.github.io"</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="1.2.4"> 字符串切割 split </h2>

<p>我们需要切割某个字符串时可以用 <code>split</code> 方法，需要注意的是，返回的结果是个<strong>数组</strong>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> str = <span class="string">"Hello，world !"</span></div><div class="line"><span class="built_in">print</span>(str.<span class="built_in">split</span>(separator: <span class="string">"，"</span>))</div><div class="line"></div><div class="line"><span class="comment">// 输出：</span></div><div class="line"><span class="comment">// ["Hello", "world !"]</span></div></pre></td></tr></table></figure>
<h2 id="1.2.5"> KVC </h2>

<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> name = <span class="string">"ifelseboyxx"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Swift 4 中 Apple 引入了新的 KeyPath 的表达方式，现在，对于类型 <code>MyClass</code> 中的<strong>变量</strong> <code>name</code>，对应的 KeyPath 可以写为 <code>\MyClass.name</code>，利用 KVC 修改 <code>name</code> 值的话，我们可以这么操作：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> object = <span class="type">MyClass</span>()</div><div class="line"><span class="built_in">print</span>(<span class="string">"name: \(object.name)"</span>)</div><div class="line"><span class="comment">// set</span></div><div class="line">object[keyPath: \<span class="type">MyClass</span>.name] = <span class="string">"ifelseboy"</span></div><div class="line"><span class="comment">// get</span></div><div class="line"><span class="built_in">print</span>(<span class="string">"name: \(object[keyPath: \MyClass.name])"</span>)</div><div class="line"></div><div class="line"><span class="comment">// 输出：</span></div><div class="line"><span class="comment">// name: ifelseboyxx</span></div><div class="line"><span class="comment">// name: ifelseboy</span></div></pre></td></tr></table></figure>
<p>另外 Swift 4 中 <code>struct</code> 同样支持 KVC ：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> age: <span class="type">Int</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = <span class="type">MyStruct</span>(age: <span class="number">18</span>)</div><div class="line"><span class="built_in">print</span>(<span class="string">"我今年 \(obj.age) 岁了"</span>)</div><div class="line">obj[keyPath: \<span class="type">MyStruct</span>.age] = <span class="number">8</span></div><div class="line"><span class="built_in">print</span>(<span class="string">"我今年 \(obj[keyPath: \MyStruct.age]) 岁了"</span>)</div><div class="line"></div><div class="line"><span class="comment">// 输出：</span></div><div class="line"><span class="comment">// 我今年 18 岁了</span></div><div class="line"><span class="comment">// 我今年 8 岁了</span></div></pre></td></tr></table></figure>
<h2 id="1.2.6"> Swift 中值类型和引用类型注意点 </h2>

<p>KVC 一节中代码里有个注意点：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = <span class="type">MyStruct</span>(age: <span class="number">18</span>)</div><div class="line"><span class="comment">//替换为</span></div><div class="line"><span class="keyword">let</span> obj = <span class="type">MyStruct</span>(age: <span class="number">18</span>)</div></pre></td></tr></table></figure>
<p>是编译不过的，会报错：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="type">Cannot</span> assign to immutable expression of type '<span class="type">Int'</span></div></pre></td></tr></table></figure>
<p>笔者初次也犯了这样的错误，想当然的认为 <code>MyClass</code> 用 <code>let</code> 声明的是没有问题的，<code>struct</code> 也一样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> object = <span class="type">MyClass</span>()</div></pre></td></tr></table></figure>
<p><strong>其实原因很简单，swift 中 Class 是引用类型的，而 struct 是值类型的：值类型在被赋给一个变量，或被传给函数时，实际是做了一次拷贝。引用类型在被赋给一个变量，或被传给函数时，传递的是引用。</strong></p>
<h2 id="1.2.7"> KVO </h2>

<p>很遗憾，依然只有 <code>NSObject</code> 才能支持 KVO，另外由于 Swift 为了效率，默认禁用了动态派发，因此想用 Swift 来实现 KVO，我们还需要做额外的工作，那就是将想要观测的对象标记为 <code>dynamic</code> 和 <code>@objc</code>，下面的 🌰 是 <code>ViewController</code> 监听 <code>MyClass</code> 的 <code>date</code> 属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>: <span class="title">NSObject</span> </span>&#123;</div><div class="line">    <span class="meta">@objc</span> <span class="keyword">dynamic</span> <span class="keyword">var</span> date = <span class="type">Date</span>()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">var</span> myObject: <span class="type">MyClass</span>!</div><div class="line">    <span class="keyword">var</span> observation: <span class="type">NSKeyValueObservation</span>?</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.viewDidLoad()</div><div class="line">        </div><div class="line">        myObject = <span class="type">MyClass</span>()</div><div class="line">        <span class="built_in">print</span>(<span class="string">"当前日期：\(myObject.date)"</span>)</div><div class="line">    </div><div class="line">        observation = myObject.observe(\<span class="type">MyClass</span>.date, options: [.old,.new], changeHandler: &#123; (<span class="number">_</span>, change) <span class="keyword">in</span></div><div class="line">            <span class="keyword">if</span> <span class="keyword">let</span> newDate = change.newValue , <span class="keyword">let</span> oldDate = change.oldValue &#123;</div><div class="line">                <span class="built_in">print</span>(<span class="string">"日期发生变化 old：\(oldDate) new：\(newDate) "</span>)</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">        </div><div class="line">        <span class="type">DispatchQueue</span>.main.asyncAfter(deadline: <span class="type">DispatchTime</span>.now() + <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">self</span>.myObject.date = <span class="type">Date</span>()</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 输出：</span></div><div class="line"><span class="comment">// 当前日期：2017-12-07 06:31:26 +0000</span></div><div class="line"><span class="comment">// 日期发生变化 old：2017-12-07 06:31:26 +0000 new：2017-12-07 06:31:27 +0000</span></div></pre></td></tr></table></figure>
<p>在 Objective-C 中我们几乎可以没有限制地对所有满足 KVC 的属性进行监听，<strong>而现在我们需要属性有 <code>dynamic</code> 和 <code>@objc</code> 进行修饰</strong>。大多数情况下，我们想要观察的类包含这两个修饰 (除非这个类的开发者有意为之，否则一般也不会有人愿意多花功夫在属性前加上它们，因为这毕竟要损失一部分性能)，并且有时候我们很可能也无法修改想要观察的类的源码。遇到这样的情况的话，<strong>一个可能可行的方案是继承这个类并且将需要观察的属性使用 <code>dynamic</code> 和 <code>@objc</code> 进行重写。</strong>比如刚才我们的 <code>MyClass</code> 中如果 <code>date</code> <strong>没有相应标注的话</strong>，我们可能就需要一个新的 <code>MyChildClass</code>了： </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>: <span class="title">NSObject</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> date = <span class="type">Date</span>()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyChildClass</span>: <span class="title">MyClass</span> </span>&#123;</div><div class="line">    <span class="meta">@objc</span> <span class="keyword">dynamic</span> <span class="keyword">override</span> <span class="keyword">var</span> date: <span class="type">Date</span> &#123;</div><div class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="keyword">super</span>.date &#125;</div><div class="line">        <span class="keyword">set</span> &#123; <span class="keyword">super</span>.date = newValue &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">var</span> myObject: <span class="type">MyChildClass</span>!</div><div class="line">    <span class="keyword">var</span> observation: <span class="type">NSKeyValueObservation</span>?</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.viewDidLoad()</div><div class="line">        </div><div class="line">        myObject = <span class="type">MyChildClass</span>()</div><div class="line">        <span class="built_in">print</span>(<span class="string">"当前日期：\(myObject.date)"</span>)</div><div class="line">    </div><div class="line">        observation = myObject.observe(\<span class="type">MyChildClass</span>.date, options: [.old,.new], changeHandler: &#123; (<span class="number">_</span>, change) <span class="keyword">in</span></div><div class="line">            <span class="keyword">if</span> <span class="keyword">let</span> newDate = change.newValue , <span class="keyword">let</span> oldDate = change.oldValue &#123;</div><div class="line">                <span class="built_in">print</span>(<span class="string">"日期发生变化 old：\(oldDate) new：\(newDate) "</span>)</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">        </div><div class="line">        <span class="type">DispatchQueue</span>.main.asyncAfter(deadline: <span class="type">DispatchTime</span>.now() + <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">self</span>.myObject.date = <span class="type">Date</span>()</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 输出：</span></div><div class="line"><span class="comment">// 当前日期：2017-12-07 06:36:50 +0000</span></div><div class="line"><span class="comment">// 日期发生变化 old：2017-12-07 06:36:50 +0000 new：2017-12-07 06:36:51 +0000</span></div></pre></td></tr></table></figure>
<h2 id="1.2.8"> Swift UIButton 状态的叠加 </h2> 

<p>在 Objective-C 中，如果我们想叠加按钮的某个状态，可以这么写：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UIButton</span> * button = [<span class="built_in">UIButton</span> buttonWithType:<span class="built_in">UIButtonTypeCustom</span>];</div><div class="line">[button setTitle:<span class="string">@"Test"</span> forState:<span class="built_in">UIControlStateNormal</span> | <span class="built_in">UIControlStateSelected</span>];</div></pre></td></tr></table></figure>
<p>对应的 Swift 我们可以这么写：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> btn = <span class="type">UIButton</span>.<span class="keyword">init</span>(type: .custom)</div><div class="line">btn.setTitle(<span class="string">"hehe"</span>, <span class="keyword">for</span>: [.normal ,.selected])</div></pre></td></tr></table></figure>
<p>把需要叠加的状态用个<strong>数组</strong>装起来就行了。</p>
<h2 id="1.2.9"> Swift 中的 “@synchronized” </h2> 

<p>在 Objective-C 中，我们可以用 <code>@synchronized</code> 这个关键字可以用来修饰一个变量，并为其自动加上和解除互斥锁。这样，可以保证变量在作用范围内不会被其他线程改变：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)myMethod:(<span class="keyword">id</span>)anObj &#123;</div><div class="line">    <span class="keyword">@synchronized</span>(anObj) &#123;</div><div class="line">        <span class="comment">// 在括号内持有 anObj 锁</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>虽然这个方法很简单好用，但是很不幸的是在 Swift 中它已经 (或者是暂时) 不存在了。其实 <code>@synchronized</code> 在幕后做的事情是调用了 <code>objc_sync</code> 中的 <code>objc_sync_enter</code> 和 <code>objc_sync_exit</code> 方法，并且加入了一些异常判断。因此，在 Swift 中，如果我们忽略掉那些异常的话，我们想要 lock 一个变量的话，可以这样写：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">myMethod</span><span class="params">(anObj: AnyObject!)</span></span> &#123;</div><div class="line">    objc_sync_enter(anObj)</div><div class="line"></div><div class="line">    <span class="comment">// 在 enter 和 exit 之间持有 anObj 锁</span></div><div class="line"></div><div class="line">    objc_sync_exit(anObj)</div><div class="line">&#125;</div><div class="line">``` </div><div class="line">更进一步，如果我们喜欢以前的那种形式，甚至可以写一个全局的方法，并接受一个闭包，来将 `objc_sync_enter` 和 `objc_sync_exit` 封装起来：</div><div class="line"></div><div class="line">```swift</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">synchronized</span><span class="params">(<span class="number">_</span> lock: AnyObject, closure: <span class="params">()</span></span></span> -&gt; ()) &#123;</div><div class="line">    objc_sync_enter(lock)</div><div class="line">    closure()</div><div class="line">    objc_sync_exit(lock)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 使用：</span></div><div class="line">synchronized(<span class="keyword">self</span>) &#123;</div><div class="line">            </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样使用起来就和 Objective-C 中 <code>@synchronized</code> 很像了。</p>
<p>再举个 🌰 ，如果我们想为某个类实现一个线程安全的 <code>setter</code>，可以这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Obj</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> _str = <span class="string">"123"</span></div><div class="line">    <span class="keyword">var</span> str: <span class="type">String</span> &#123;</div><div class="line">        <span class="keyword">get</span> &#123;</div><div class="line">            <span class="keyword">return</span> _str</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">set</span> &#123;</div><div class="line">            synchronized(<span class="keyword">self</span>) &#123;</div><div class="line">                _str = newValue</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="1.3.0"> 自定义日志输出 </h2>

<p>在 Objective-C 中，我们通常会自定义日志输出来完善信息以及避免 <code>release</code> 下的输出，比如下面这种，可以额外提供行数、方法名等信息：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#ifdef DEBUG</span></div><div class="line"><span class="meta">#define XXLog(fmt, ...) NSLog((@<span class="meta-string">"%s [Line %d] "</span> fmt), __PRETTY_FUNCTION__, __LINE__, ##__VA_ARGS__)</span></div><div class="line"><span class="meta">#else</span></div><div class="line"><span class="meta">#define XXLog(...)</span></div><div class="line"><span class="meta">#endif</span></div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;</div><div class="line">    <span class="comment">// Override point for customization after application launch.</span></div><div class="line">    </div><div class="line">    XXLog(<span class="string">@"ifelseboyxx"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 输出：</span></div><div class="line"><span class="comment">// 2017-12-08 13:32:02.211306+0800 Demo[17902:88775537] -[AppDelegate application:didFinishLaunchingWithOptions:] [Line 28] ifelseboyxx</span></div></pre></td></tr></table></figure>
<p>在 Swift 中，我们可以这样自定义：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">xxprint</span>&lt;T&gt;<span class="params">(<span class="number">_</span> message: T, filePath: String = #file, line: Int = #line, function: String = #function)</span></span> &#123;</div><div class="line">    #<span class="keyword">if</span> <span class="type">DEBUG</span></div><div class="line">        <span class="keyword">let</span> fileName = (filePath <span class="keyword">as</span> <span class="type">NSString</span>).lastPathComponent.replacingOccurrences(of: <span class="string">".Swift"</span>, with: <span class="string">""</span>)</div><div class="line">        <span class="keyword">let</span> dateFormatter = <span class="type">DateFormatter</span>()</div><div class="line">        dateFormatter.locale = <span class="type">Locale</span>.current</div><div class="line">        dateFormatter.dateFormat = <span class="string">"yyyy-MM-dd HH:mm:ss"</span></div><div class="line">        <span class="built_in">print</span>(<span class="string">"["</span> + dateFormatter.string(from: <span class="type">Date</span>()) + <span class="string">" "</span> + fileName + <span class="string">" "</span> + function + <span class="string">" \(line)"</span> + <span class="string">"]："</span> + <span class="string">"\(message)"</span>)</div><div class="line">    #endif</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.viewDidLoad()</div><div class="line">    </div><div class="line">        xxprint(<span class="string">"ifelseboyxx"</span>)</div><div class="line">        <span class="type">DispatchQueue</span>.main.asyncAfter(deadline: <span class="type">DispatchTime</span>.now() + <span class="number">1</span>) &#123;</div><div class="line">            xxprint(<span class="string">"ifelseboyxx"</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 输出：</span></div><div class="line"><span class="comment">// [2017-12-08 13:49:38 ViewController.swift viewDidLoad() 27]：ifelseboyxx</span></div><div class="line"><span class="comment">// [2017-12-08 13:49:39 ViewController.swift viewDidLoad() 29]：ifelseboyxx</span></div></pre></td></tr></table></figure>
<h2 id="1.3.1"> Swift 中的 “readonly” </h2>

<p>在 Objective-C 中，我们通常把属性声明为 <code>readonly</code> 来提醒别人：“不要修改！！”，通常这么写：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>如果外部尝试修改的话，会编译错误：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">   </div><div class="line">    Person *p = [Person new];</div><div class="line">    p.name = <span class="string">@"ifelseboyxx"</span>;</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 编译错误：</span></div><div class="line"><span class="comment">// Assignment to readonly property</span></div></pre></td></tr></table></figure>
<p>有些情况下，我们希望内部可以点语法访问 <code>name</code> 属性，也就是 <code>self.name</code>，但是因为是 <code>readonly</code> 的，会编译错误：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">instancetype</span>)init &#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.name = <span class="string">@"ifelseboyxx"</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="comment">// 编译错误：</span></div><div class="line"><span class="comment">// Assignment to readonly property</span></div></pre></td></tr></table></figure>
<p>这时候我们就会在内部的 <code>extension</code> 重新声明一个 <code>readwrite</code>的同样的属性，也就是<strong>“外部只读，内部可写”</strong>：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> ()</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readwrite</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>在 Swift 中，我们可能有同样的场景。这里就不得不提到 <code>private</code> 和 <code>fileprivate</code> 关键字了。<br><code>private</code>表示声明为私有的实体只能在其声明的范围内被访问。比如我在 <code>MyClass</code> 中声明了一个私有的 <code>name</code> 属性，外部访问的话会编译错误：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">var</span> name: <span class="type">String</span> = <span class="string">"Test"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.viewDidLoad()</div><div class="line"></div><div class="line">        <span class="keyword">let</span> only = <span class="type">MyClass</span>()</div><div class="line">        <span class="built_in">print</span>(only.name) </div><div class="line">        only.name = <span class="string">"ifelseboyxxv587"</span>       </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 编译异常：</span></div><div class="line"><span class="comment">// 'name' is inaccessible due to 'private' protection level</span></div></pre></td></tr></table></figure>
<p>而 <code>fileprivate</code>，看命名我们大概能猜到，就是将对实体的访问权限于它声明的源文件。通俗点讲，比如我上面的代码都是在 <code>ViewController.swift</code> 这个文件里的，我把 <code>private</code> 修改为 <code>fileprivate</code>，就不会编译错误了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</div><div class="line">    fileprivate <span class="keyword">var</span> name: <span class="type">String</span> = <span class="string">"Test"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么如果非 <code>ViewController.swift</code> 文件，也想访问 <code>MyClass</code> 的 <code>name</code> 属性该怎么办呢？我们可以把 <code>name</code> 属性声明为 <code>fileprivate(set)</code>，就要就达到类似 Objective-C 中的 <code>readonly</code> 效果了 ：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ViewController.swift 文件</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</div><div class="line">    fileprivate(<span class="keyword">set</span>) <span class="keyword">var</span> name: <span class="type">String</span> = <span class="string">"Test"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.viewDidLoad()</div><div class="line"></div><div class="line">        <span class="keyword">let</span> only = <span class="type">MyClass</span>()</div><div class="line">        <span class="built_in">print</span>(only.name)</div><div class="line">        only.name = <span class="string">"ifelseboyxxv587"</span></div><div class="line">        <span class="built_in">print</span>(only.name)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 编译正常，ViewController.swift 文件内可读可写</span></div><div class="line"><span class="comment">// 输出：</span></div><div class="line"><span class="comment">// Test</span></div><div class="line"><span class="comment">// ifelseboyxxv587</span></div></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// AppDelegate.swift 文件</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(<span class="number">_</span> application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?)</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line">        <span class="comment">// Override point for customization after application launch.</span></div><div class="line"></div><div class="line">    <span class="keyword">let</span> only = <span class="type">MyClass</span>()</div><div class="line">    <span class="built_in">print</span>(only.name) <span class="comment">//只能读</span></div><div class="line">    only.name = <span class="string">"ifelseboyxxv587"</span> <span class="comment">//这里报错，不能写</span></div><div class="line">        </div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 编译异常：</span></div><div class="line"><span class="comment">// Cannot assign to property: 'name' setter is inaccessible</span></div></pre></td></tr></table></figure>
<h2 id="1.3.2"> 作用域：do 语句块 </h2>

<p>在 Objective-C 中，我们可以利用 <code>{}</code> 来开辟新的作用域，来避免对象名称重复的问题：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *ha = <span class="string">@"测试一"</span>;</div><div class="line">    </div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSString</span> *ha = <span class="string">@"测试二"</span>;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,ha);</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,ha);</div><div class="line"></div><div class="line"><span class="comment">// 输出：</span></div><div class="line"><span class="comment">// 2017-12-11 16:55:20.303132+0800 Demo[48418:93027416] 测试二</span></div><div class="line"><span class="comment">// 2017-12-11 16:55:20.303316+0800 Demo[48418:93027416] 测试一</span></div></pre></td></tr></table></figure>
<p>在 Swift 中，取代 <code>{}</code> 的是 <code>do {}</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> ha = <span class="string">"测试一"</span></div><div class="line">        </div><div class="line"><span class="keyword">do</span> &#123;</div><div class="line">    <span class="keyword">let</span> ha = <span class="string">"测试二"</span></div><div class="line">    <span class="built_in">print</span>(ha)</div><div class="line">&#125;</div><div class="line">        </div><div class="line"><span class="built_in">print</span>(ha)</div><div class="line"></div><div class="line"><span class="comment">// 输出：</span></div><div class="line"><span class="comment">// 测试二</span></div><div class="line"><span class="comment">// 测试一</span></div></pre></td></tr></table></figure>
<h2 id="1.3.3"> 倒序 reversed() </h2>

<p>在 Objective-C 中，我们如果想倒序数组一般这样：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *array = @[<span class="string">@"1"</span>,<span class="string">@"2"</span>,<span class="string">@"3"</span>];</div><div class="line">    </div><div class="line"><span class="built_in">NSArray</span> *reversedArray = [[array reverseObjectEnumerator] allObjects];</div><div class="line"></div><div class="line"><span class="comment">// 输出：</span></div><div class="line"><span class="comment">// 2017-12-11 17:39:57.127466+0800 Demo[49004:93210504] (</span></div><div class="line">    <span class="number">3</span>,</div><div class="line">    <span class="number">2</span>,</div><div class="line">    <span class="number">1</span></div><div class="line">)</div></pre></td></tr></table></figure>
<p>在 Swift 中，相对简单点：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> arr:[<span class="type">String</span>] = [<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>]</div><div class="line"><span class="keyword">let</span> reversedArr:[<span class="type">String</span>] = arr.reversed()</div><div class="line"></div><div class="line"><span class="comment">// 输出：</span></div><div class="line"><span class="comment">// ["3", "2", "1"]</span></div></pre></td></tr></table></figure>
<h2 id="1.3.3"> 标签语句：指定跳出某个条件语句 </h2>

<p>在 Objective-C 中，如果遇到多层嵌套的条件语句，我们如果想要指定跳出某个条件语句是很不方便的。比如有两个循环，<strong>一旦找到它们相同的，就立刻停止循环</strong>，我们可能会这么做：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *arr1 = @[<span class="string">@"1"</span>,<span class="string">@"2"</span>,<span class="string">@"3"</span>,<span class="string">@"4"</span>,<span class="string">@"5"</span>];</div><div class="line"><span class="built_in">NSArray</span> *arr2 = @[<span class="string">@"4"</span>,<span class="string">@"6"</span>,<span class="string">@"8"</span>,<span class="string">@"9"</span>,<span class="string">@"2"</span>];</div><div class="line"></div><div class="line"><span class="built_in">BOOL</span> finded = <span class="literal">NO</span>;</div><div class="line"><span class="keyword">for</span> (<span class="built_in">NSString</span> *x <span class="keyword">in</span> arr1) &#123;</div><div class="line">    <span class="keyword">if</span> (finded) &#123;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"x：%@"</span>,x);</div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *y <span class="keyword">in</span> arr2) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"y：%@"</span>,y);</div><div class="line">        <span class="keyword">if</span> ([x isEqualToString:y]) &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"找到相等的了：%@"</span>,x);</div><div class="line">            finded = <span class="literal">YES</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们需要借助 <code>finded</code> 这个 <code>BOOL</code>，来方便我们跳出循环。在 Swift 中，我们就可以利用标签语句，来指定具体跳出哪个循环，语法是这样的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">标签名: 条件语句 &#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的 🌰 我们可以这么写：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> arr1 = [<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>,<span class="string">"4"</span>,<span class="string">"5"</span>]</div><div class="line"><span class="keyword">let</span> arr2 = [<span class="string">"4"</span>,<span class="string">"6"</span>,<span class="string">"8"</span>,<span class="string">"9"</span>,<span class="string">"2"</span>]</div><div class="line">        </div><div class="line">label: <span class="keyword">for</span> x <span class="keyword">in</span> arr1 &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"x： \(x)"</span>)</div><div class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> arr2 &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"y： \(y)"</span>)</div><div class="line">        <span class="keyword">if</span> x == y &#123;</div><div class="line">            <span class="built_in">print</span>(<span class="string">"找到相等的了：\(y)"</span>)</div><div class="line">            <span class="keyword">break</span> label</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码，我们把第一层循环定义了标签：<code>label</code>。在第二层循环中，一旦条件成立，立刻跳出第一层循环 <code>label</code>。这个特性，可以说十分方便了！</p>
<h2 id="1.3.5"> 优雅的定义通知名称 </h2>

<p>在 Objective-C 中，我们自定义通知时，对于名称的定义一般都有规范：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// xxx.h </span></div><div class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> XXXXNotification;</div><div class="line"></div><div class="line"><span class="comment">// xxx.m </span></div><div class="line"><span class="built_in">NSString</span> * <span class="keyword">const</span> XXXXNotification = <span class="string">@"XXXXNotification"</span>;</div></pre></td></tr></table></figure>
<p>在 Swift 中，我们可以参考 <a href="https://github.com/Alamofire/Alamofire" target="_blank" rel="external">Alamofire</a> 的方式，创建个专门存放通知名的文件，扩展 <code>Notification.Name</code> 并以结构体 <code>struct</code> 方式声明：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// XXNotification.swift 文件</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> Foundation</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Notification</span>.<span class="title">Name</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Task</span> </span>&#123;</div><div class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> 通知名 = <span class="type">Notification</span>.<span class="type">Name</span>(rawValue: <span class="string">"org.target名称.notification.name.task.通知名"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后我们就可以愉快的使用了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// add</span></div><div class="line"><span class="type">NotificationCenter</span>.<span class="keyword">default</span>.addObserver(<span class="keyword">self</span>, selector: #selector(myNotification(<span class="number">_</span> :)), name: <span class="type">NSNotification</span>.<span class="type">Name</span>.<span class="type">Task</span>.通知名, object: <span class="keyword">self</span>)</div><div class="line"></div><div class="line"><span class="comment">// post</span></div><div class="line"><span class="type">NotificationCenter</span>.<span class="keyword">default</span>.post(name: <span class="type">NSNotification</span>.<span class="type">Name</span>.<span class="type">Task</span>.通知名, object: <span class="keyword">self</span>)</div><div class="line"></div><div class="line"><span class="comment">// remove</span></div><div class="line"><span class="type">NotificationCenter</span>.<span class="keyword">default</span>.removeObserver(<span class="keyword">self</span>, name: <span class="type">NSNotification</span>.<span class="type">Name</span>.<span class="type">Task</span>.通知名, object: <span class="keyword">self</span>)</div></pre></td></tr></table></figure>


                
            </div>


            <!-- Comments -->
            
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    




                </div>
            
        </div>
    </div>
</article>

    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">

                <ul class="list-inline text-center">
                    

                    

                    

                    

                    

                    

                    
                </ul>
                <p class="copyright text-muted">Copyright &copy; Hexo-CleanBlog 2017 <br></p>
            </div>
        </div>
    </div>
</footer>


    <!-- After footer scripts -->
    
<!-- jQuery -->
<script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>

<!-- Bootstrap -->
<script src="//cdn.bootcss.com/bootstrap/3.3.5/js/bootstrap.min.js"></script>

<!-- Gallery -->
<script src="//cdn.bootcss.com/featherlight/1.7.1/featherlight.gallery.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Disqus Comments -->



</body>

</html>
<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Swift 知识小集 · ifelseboyxx's Blog</title><meta name="description" content="Swift 知识小集 - ifelseboyxx"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/user.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="ifelseboyxx's Blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/img_header.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://weibo.com/3224111110/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/ifelseboyxx" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="http://www.jianshu.com/u/c1fef1c0da1a" target="_blank" class="nav-list-link">JIANSHU</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Swift 知识小集</h1><div class="post-info">2017年12月7日</div><div class="post-content"><p>以下内容均是笔者学习过程中<strong>收集</strong>的知识点，顺序比较跳跃，初衷是为了方便查阅，顺便加深记忆。<strong>内容会不断更新</strong>，如果有什么问题或者有好的 Swift 方面的语法糖或者知识点也可以提出来，我会挑选斟酌后收录，欢迎大家关注～</p>
<blockquote>
<p>version： Swift =&gt; 4.0 </p>
</blockquote>
<p><strong>目录：</strong></p>
<blockquote>
<p><a href="#1.1.1">Associated Object</a><br><a href="#1.1.2">Delegate 声明为 weak</a><br><a href="#1.1.3">可选协议和协议扩展</a><br><a href="#1.1.4">单例</a><br><a href="#1.1.5">输出格式化</a><br><a href="#1.1.6">Selector</a><br><a href="#1.1.7">将 protocol 的方法声明为 mutating</a><br><a href="#1.1.8">数组遍历 enumerate</a><br><a href="#1.1.9">输入输出参数 inout</a><br><a href="#1.2.0">Default 参数</a><br><a href="#1.2.1">延迟加载 lazy</a><br><a href="#1.2.2">编译标记</a><br><a href="#1.2.3">换行符</a><br><a href="#1.2.4">字符串切割 split</a><br><a href="#1.2.5">KVC</a><br><a href="#1.2.6">Swift 中值类型和引用类型注意点</a><br><a href="#1.2.7">KVO</a><br><a href="#1.2.8">Swift UIButton 状态的叠加</a></p>
</blockquote>
<a id="more"></a>
<h2 id="1.1.1"> Associated Object </h2>

<p>Objective-C 的 runtime 里的 Associated Object 允许我们在使用 Category 扩展现有的类的功能的时候，直接添加实例变量。在 Swift 中 extension 不能添加<strong>存储属性</strong>，我们可以利用 Associated Object 来实现，比如下面的 <code>title</code> 「实际上」是一个存储属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// MyClass.swift</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">// MyClassExtension.swift</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">var</span> key: <span class="type">Void</span>?</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">MyClass</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> title: <span class="type">String</span>? &#123;</div><div class="line">        <span class="keyword">get</span> &#123;</div><div class="line">            <span class="keyword">return</span> swift_getAssociatedObject(<span class="keyword">self</span>, &amp;key) <span class="keyword">as</span>? <span class="type">String</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">set</span> &#123;</div><div class="line">            swift_setAssociatedObject(<span class="keyword">self</span>,</div><div class="line">                &amp;key, newValue,</div><div class="line">                .swift_ASSOCIATION_RETAIN_NONATOMIC)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 测试</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">printTitle</span><span class="params">(<span class="number">_</span> input: MyClass)</span></span> &#123;</div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> title = input.title &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"Title: \(title)"</span>)</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"没有设置"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> a = <span class="type">MyClass</span>()</div><div class="line">printTitle(a)</div><div class="line">a.title = <span class="string">"Swifter.tips"</span></div><div class="line">printTitle(a)</div><div class="line"></div><div class="line"><span class="comment">// 输出：</span></div><div class="line"><span class="comment">// 没有设置</span></div><div class="line"><span class="comment">// Title: Swifter.tips”</span></div></pre></td></tr></table></figure>
<h2 id="1.1.2"> Delegate 声明为 weak </h2>

<p>Swift 中 Delegate 需要被声明成 <code>weak</code>，来避免访问到已被回收的内存而导致崩溃，如果我们像下面这样，是编译不过的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">MyClassDelegate</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">method</span><span class="params">()</span></span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</div><div class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> delegate: <span class="type">MyClassDelegate</span>?</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>, <span class="title">MyClassDelegate</span> </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    <span class="keyword">var</span> someInstance: <span class="type">MyClass</span>!</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.viewDidLoad()</div><div class="line"></div><div class="line">        someInstance = <span class="type">MyClass</span>()</div><div class="line">        someInstance.delegate = <span class="keyword">self</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">method</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"Do something"</span>)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 编译失败</span></div><div class="line"><span class="comment">// 'weak' may only be applied to class and class-bound protocol types, not 'MyClassDelegate'</span></div></pre></td></tr></table></figure>
<p>这是因为 Swift 的 protocol 是可以被除了 class 以外的其他类型遵守的，而对于像 <code>struct</code> 或是 <code>enum</code> 这样的类型，本身就不通过引用计数来管理内存，所以也不可能用 <code>weak</code> 这样的 ARC 的概念来进行修饰。</p>
<p>想要在 Swift 中使用 weak delegate，我们就需要将 protocol 限制在 class 内：</p>
<ul>
<li>一种做法是将 protocol 声明为 Objective-C 的，这可以通过在 protocol 前面加上 <code>@swift</code> 关键字来达到，Objective-C 的 protocol 都只有类能实现，因此使用 weak 来修饰就合理了：</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@swift <span class="class"><span class="keyword">protocol</span> <span class="title">MyClassDelegate</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">method</span><span class="params">()</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>另一种<strong>可能更好</strong>的办法是在 protocol 声明的名字后面加上 <code>class</code>，这可以为编译器显式地指明这个 protocol 只能由 <code>class</code> 来实现，避免了过多的不必要的 Objective-C 兼容：</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">MyClassDelegate</span>: <span class="title">class</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">method</span><span class="params">()</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="1.1.3"> 可选协议和协议扩展 </h2>

<p>Objective-C 中的 protocol 里存在 <code>@optional</code> 关键字，被这个关键字修饰的方法并非必须要被实现，原生的 Swift protocol 里没有可选项，所有定义的方法都是必须实现的，如果不是实现是无法编译的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>,<span class="title">MyProtocol</span> </span>&#123; &#125;</div><div class="line"></div><div class="line"><span class="comment">// 编译失败</span></div><div class="line"><span class="comment">// Type 'ViewController' does not conform to protocol 'MyProtocol'</span></div></pre></td></tr></table></figure>
<p>如果我们想要像 Objective-C 里那样定义可选的协议方法，就需要将协议本身和可选方法都定义为 Objective-C 的，也即在 protocol 定义之前加上 <code>@swift</code>，方法之前加上 <code>@swift optional</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@swift <span class="class"><span class="keyword">protocol</span> <span class="title">MyProtocol</span> </span>&#123;</div><div class="line">    @swift <span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">myMethod</span><span class="params">()</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另外，对于所有的声明，它们的前缀修饰是完全分开的，<strong>也就是说你不能像是在 Objective-C 里那样用一个 <code>@optional</code> 指定接下来的若干个方法都是可选的了，</strong>必须对每一个可选方法添加前缀，对于没有前缀的方法来说，它们是默认必须实现的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@swift <span class="class"><span class="keyword">protocol</span> <span class="title">MyProtocol</span> </span>&#123;</div><div class="line">    @swift <span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">optionalMethod</span><span class="params">()</span></span>        <span class="comment">// 可选</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">necessaryMethod</span><span class="params">()</span></span>                      <span class="comment">// 必须</span></div><div class="line">    @swift <span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">anotherOptionalMethod</span><span class="params">()</span></span> <span class="comment">// 可选</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>一个不可避免的限制是</strong>，使用 <code>@swift</code> 修饰的 protocol 就只能被 <code>class</code> 实现了，也就是说，对于 <code>struct</code> 和 <code>enum</code> 类型，我们是无法令它们所实现的协议中含有可选方法或者属性的。另外，实现它的 <code>class</code> 中的方法还必须也被标注为 <code>@swift</code>，或者整个类就是继承自 <code>NSObject</code>。对于这种问题，在 Swift 2.0 中，我们有了另一种选择，那就是使用 <strong>protocol extension</strong>。我们可以在声明一个 protocol 之后再用 extension 的方式给出部分方法<strong>默认的实现</strong>，这样这些方法在实际的类中就是可选实现的了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">MyProtocol</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">optionalMethod</span><span class="params">()</span></span>        <span class="comment">// 可选</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">necessaryMethod</span><span class="params">()</span></span>       <span class="comment">// 必须</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">anotherOptionalMethod</span><span class="params">()</span></span> <span class="comment">// 可选</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">MyProtocol</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">//默认的可选实现</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">optionalMethod</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"optionalMethod"</span>)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//默认的可选实现</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">anotherOptionalMethod</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"anotherOptionalMethod"</span>)</div><div class="line">    &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>,<span class="title">MyProtocol</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">// 必须的实现</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">necessaryMethod</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"necessaryMethod"</span>)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.viewDidLoad()</div><div class="line">        </div><div class="line">        <span class="keyword">self</span>.optionalMethod();</div><div class="line">        <span class="keyword">self</span>.necessaryMethod();</div><div class="line">        <span class="keyword">self</span>.anotherOptionalMethod();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 输出：</span></div><div class="line"><span class="comment">// optionalMethod</span></div><div class="line"><span class="comment">// necessaryMethod</span></div><div class="line"><span class="comment">// necessaryMethod</span></div></pre></td></tr></table></figure>
<h2 id="1.1.4"> 单例 </h2>

<p>Swift 中的单例非常简单，Swift 1.2 以及之后：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>  </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">let</span> sharedInstance = <span class="type">Singleton</span>()</div><div class="line">    <span class="keyword">private</span> <span class="keyword">init</span>() &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种写法不但是线程安全的，也是懒加载的，<code>let</code> 定义的属性本身就是线程安全的，同时 <code>static</code> 定义的是一个 class constant，拥有全局作用域和懒加载特性。</p>
<p>另外，这个类型中加入了一个私有的初始化方法，来覆盖默认的公开初始化方法，这让项目中的其他地方不能够通过 init 来生成自己的 <code>Singleton</code> 实例，也保证了类型单例的唯一性。如果你需要的是类似 default 的形式的单例 (也就是说这个类的使用者可以创建自己的实例) 的话，可以去掉这个私有的 <code>init</code> 方法。</p>
<h2 id="1.1.5"> 输出格式化 </h2>

<p>在 Objective-C 中的 <code>%@</code> 这样的格式在指定的位置设定占位符，然后通过参数的方式将实际要输出的内容补充完整。例如 Objective-C 中常用的向控制台输出的 <code>NSLog</code> 方法就使用了这种格式化方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">float a = <span class="number">1.234567</span>;</div><div class="line"><span class="type">NSString</span> *b = @<span class="string">"Helllo"</span>;</div><div class="line"><span class="type">NSLog</span>(@<span class="string">"float：%.2f  str：%p"</span>,a,b);</div><div class="line"></div><div class="line"><span class="comment">// 输出：</span></div><div class="line"><span class="comment">// float：1.23  str：0x1024a1078</span></div></pre></td></tr></table></figure>
<p>对应 Swift 中我们可以这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a = <span class="number">1.234567</span></div><div class="line"><span class="keyword">let</span> b = <span class="string">"Helllo"</span></div><div class="line"><span class="keyword">let</span> <span class="built_in">c</span> = <span class="type">String</span>(format:<span class="string">"float：%.2f str：%p"</span>,a,b)</div><div class="line"><span class="built_in">print</span>(<span class="built_in">c</span>)</div><div class="line"></div><div class="line"><span class="comment">// 输出：</span></div><div class="line"><span class="comment">// float：1.23 str：0x604000249e10</span></div></pre></td></tr></table></figure>
<h2 id="1.1.6"> Selector </h2>

<p><code>@selector</code> 是 Objective-C 时代的一个关键字，它可以将一个方法转换并赋值给一个 SEL 类型，它的表现很类似一个动态的函数指针。在 Swift 中没有 <code>@selector</code> 了，取而代之，从 Swift 2.2 开始我们使用 <code>#selector</code> 来从暴露给 Objective-C 的代码中获取一个 <code>selector</code>，并且因为 <code>selector</code> 是 Objective-C runtime 的概念，在 Swift 4 中，默认情况下所有的 Swift 方法在 Objective-C 中都是不可见的，所以你需要在这类方法前面加上 <code>@swift</code> 关键字，将这个方法暴露给 Objective-C，才能进行使用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> btn = <span class="type">UIButton</span>.<span class="keyword">init</span>(type: .system)</div><div class="line">btn.backgroundColor = <span class="type">UIColor</span>.red</div><div class="line">btn.frame = <span class="type">CGRect</span>(x: <span class="number">100</span>, y: <span class="number">100</span>, width: <span class="number">150</span>, height: <span class="number">40</span>)</div><div class="line">btn.setTitle(<span class="string">"Button"</span>, <span class="keyword">for</span>: .normal)</div><div class="line"><span class="comment">//无参数</span></div><div class="line">btn.addTarget(<span class="keyword">self</span>, action: #selector(btnClick), <span class="keyword">for</span>: .touchUpInside)</div><div class="line">view.addSubview(btn)</div><div class="line"></div><div class="line">@swift <span class="function"><span class="keyword">func</span> <span class="title">btnClick</span><span class="params">()</span></span>  &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"button click !"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line"><span class="comment">//有参数</span></div><div class="line">btn.addTarget(<span class="keyword">self</span>, action: #selector(btnClick(<span class="number">_</span> :)), <span class="keyword">for</span>: .touchUpInside)</div><div class="line">...</div><div class="line"></div><div class="line">@swift <span class="function"><span class="keyword">func</span> <span class="title">btnClick</span><span class="params">(<span class="number">_</span> button: UIButton)</span></span>  &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"button click !"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="1.1.7"> 将 protocol 的方法声明为 mutating </h2>

<p>Swift 的 protocol 不仅可以被 class 类型实现，也适用于 <code>struct</code> 和 <code>enum</code>，因为这个原因，我们在写给别人用的协议时需要多考虑是否使用 <code>mutating</code> 来修饰方法。Swift 的 <code>mutating</code> 关键字修饰方法是为了能在该方法中修改 <code>struct</code> 或是 <code>enum</code> 的变量，所以如果你没在协议方法里写 <code>mutating</code> 的话，别人如果用 <code>struct</code> 或者 <code>enum</code> 来实现这个协议的话，就不能在方法里改变自己的变量了，比如下面的代码是编译不过的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Vehicle</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">changeColor</span><span class="params">()</span></span></div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyCar</span>: <span class="title">Vehicle</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">var</span> color = <span class="string">"blue"</span></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">changeColor</span><span class="params">()</span></span> &#123;</div><div class="line">        color = <span class="string">"red"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 编译失败</span></div><div class="line"><span class="comment">// Cannot assign to property: 'self' is immutable</span></div></pre></td></tr></table></figure>
<p>我们应该加上 <code>mutating</code> 关键字：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Vehicle</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">changeColor</span><span class="params">()</span></span></div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyCar</span>: <span class="title">Vehicle</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">var</span> color = <span class="string">"blue"</span></div><div class="line">    </div><div class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">changeColor</span><span class="params">()</span></span> &#123;</div><div class="line">        color = <span class="string">"red"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">super</span>.viewDidLoad()</div><div class="line"></div><div class="line">    <span class="keyword">var</span> car = <span class="type">MyCar</span>()</div><div class="line">    <span class="built_in">print</span>(car.color)</div><div class="line">    car.changeColor()</div><div class="line">    <span class="built_in">print</span>(car.color)    </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 输出：</span></div><div class="line"><span class="comment">// blue</span></div><div class="line"><span class="comment">// 输出：</span></div><div class="line"><span class="comment">// red</span></div></pre></td></tr></table></figure>
<h2 id="1.1.8"> 数组遍历 enumerate </h2>

<p>使用 NSArray 时一个很常遇见的的需求是在枚举数组内元素的同时也想使用对应的<strong>下标索引</strong>，在 Objective-C 中最方便的方式是使用 NSArray 的 <code>enumerateObjectsUsingBlock:</code> ，在 Swift 中存在一个效率，安全性和可读性都很好的替代，那就是快速枚举某个数组的<code>EnumerateGenerator</code>，它的元素是同时包含了元素下标索引以及元素本身的多元组：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> arr = [<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>,<span class="string">"e"</span>]</div><div class="line"><span class="keyword">for</span> (idx, str) <span class="keyword">in</span> arr.enumerated() &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"idx: \(idx) str: \(str)"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 输出：</span></div><div class="line">idx: <span class="number">0</span> str: a</div><div class="line">idx: <span class="number">1</span> str: b</div><div class="line">idx: <span class="number">2</span> str: <span class="built_in">c</span></div><div class="line">idx: <span class="number">3</span> str: d</div><div class="line">idx: <span class="number">4</span> str: e</div></pre></td></tr></table></figure>
<h2 id="1.1.9"> 输入输出参数 inout </h2>

<p>函数参数默认是<strong>常量</strong>，如果试图在函数体中更改参数值将会导致<strong>编译错误</strong>，比如下面的例子中尝试着交换值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapTwoInts</span><span class="params">(<span class="number">_</span> a: Int, <span class="number">_</span> b: Int)</span></span> &#123;</div><div class="line">    <span class="keyword">let</span> temporaryA = a</div><div class="line">    a = b</div><div class="line">    b = temporaryA</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 编译失败</span></div><div class="line"><span class="comment">// Cannot assign to value: 'a' is a 'let' constant</span></div><div class="line"><span class="comment">// Cannot assign to value: 'b' is a 'let' constant</span></div></pre></td></tr></table></figure>
<p>如果想要一个函数可以修改参数的值，并且想要在这些修改在函数调用结束后仍然存在，那么就应该把这个参数定义为输入输出参数（In-Out Parameters）：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapTwoInts</span><span class="params">(<span class="number">_</span> a: <span class="keyword">inout</span> Int, <span class="number">_</span> b: <span class="keyword">inout</span> Int)</span></span> &#123;</div><div class="line">    <span class="keyword">let</span> temporaryA = a</div><div class="line">    a = b</div><div class="line">    b = temporaryA</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="1.2.0"> Default 参数 </h2>

<p>Swift 的方法是支持默认参数的，也就是说在声明方法时，可以给某个参数指定一个默认使用的值。在调用该方法时要是传入了这个参数，则使用传入的值，如果缺少这个输入参数，那么直接使用设定的默认值进行调用。和其他很多语言的默认参数相比较，Swift 中的默认参数限制更少，并没有所谓 <strong>“默认参数之后不能再出现无默认值的参数”</strong>这样的规则，举个例子，下面两种方法的声明在 Swift 里都是合法可用的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello1</span><span class="params">(str1: String = <span class="string">"Hello"</span>, str2: String, str3: String)</span></span> &#123;</div><div class="line">    <span class="built_in">print</span>(str1 + str2 + str3)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello2</span><span class="params">(str1: String, str2: String, str3: String = <span class="string">"World"</span>)</span></span> &#123;</div><div class="line">    <span class="built_in">print</span>(str1 + str2 + str3)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sayHello1(str2: <span class="string">" "</span>, str3: <span class="string">"World"</span>)</div><div class="line">sayHello2(str1: <span class="string">"Hello"</span>, str2: <span class="string">" "</span>)</div><div class="line"></div><div class="line"><span class="comment">//输出都是 Hello World</span></div></pre></td></tr></table></figure>
<h2 id="1.2.1"> 延迟加载 lazy </h2>

<p>延时加载或者说延时初始化是很常用的优化方法，在构建和生成新的对象的时候，内存分配会在运行时耗费不少时间，<strong>如果有一些对象的属性和内容非常复杂的话，这个时间更是不可忽略</strong>。另外，有些情况下我们并不会立即用到一个对象的所有属性，而默认情况下初始化时，<strong>那些在特定环境下不被使用的存储属性，也一样要被初始化和赋值</strong>，也是一种浪费。在 Objective-C 中，一个延迟加载一般是这样的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ClassA.h</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *testString;</div><div class="line"></div><div class="line"><span class="comment">// ClassA.m</span></div><div class="line">- (<span class="built_in">NSString</span> *)testString &#123;</div><div class="line">     <span class="keyword">if</span> (!_testString) &#123;</div><div class="line">         _testString = <span class="string">@"Hello"</span>;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"只在首次访问输出"</span>);</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> _testString;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对应在 Swift 中，使用 <code>lazy</code> 作为属性修饰符时，只能声明属性是<strong>变量</strong>，且我们需要显式地指定<strong>属性类型</strong>，否则会编译错误：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> </span>&#123;</div><div class="line">    <span class="built_in">lazy</span> <span class="keyword">let</span> str: <span class="type">String</span> = &#123;</div><div class="line">        <span class="keyword">let</span> str = <span class="string">"Hello"</span></div><div class="line">        <span class="built_in">print</span>(<span class="string">"只在首次访问输出"</span>)</div><div class="line">        <span class="keyword">return</span> str</div><div class="line">    &#125;()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 编译失败</span></div><div class="line"><span class="comment">// 'lazy' cannot be used on a let</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> </span>&#123;</div><div class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> str = &#123;</div><div class="line">        <span class="keyword">let</span> str = <span class="string">"Hello"</span></div><div class="line">        <span class="built_in">print</span>(<span class="string">"只在首次访问输出"</span>)</div><div class="line">        <span class="keyword">return</span> str</div><div class="line">    &#125;()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 编译失败</span></div><div class="line"><span class="comment">// Unable to infer complex closure return type</span></div></pre></td></tr></table></figure>
<p>我们应该声明为 <code>var</code> 并指定好类型：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> </span>&#123;</div><div class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> str: <span class="type">String</span> = &#123;</div><div class="line">        <span class="keyword">let</span> str = <span class="string">"Hello"</span></div><div class="line">        <span class="built_in">print</span>(<span class="string">"只在首次访问输出"</span>)</div><div class="line">        <span class="keyword">return</span> str</div><div class="line">    &#125;()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">super</span>.viewDidLoad()</div><div class="line"></div><div class="line">    <span class="keyword">let</span> ca = <span class="type">ClassA</span>()</div><div class="line">    <span class="built_in">print</span>(ca.str)</div><div class="line">    <span class="built_in">print</span>(ca.str)</div><div class="line">    <span class="built_in">print</span>(ca.str)   </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 输出：</span></div><div class="line"><span class="comment">// 只在首次访问输出</span></div><div class="line"><span class="comment">// Hello</span></div><div class="line"><span class="comment">// Hello</span></div><div class="line"><span class="comment">// Hello</span></div></pre></td></tr></table></figure>
<p>如果不需要做什么额外工作的话，也可以对这个 <code>lazy</code> 的属性直接写赋值语句：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">lazy</span> <span class="keyword">var</span> str: <span class="type">String</span> = <span class="string">"Hello"</span></div></pre></td></tr></table></figure>
<p>我们还可以利用 <code>lazy</code> 配合像 <code>map</code> 或是 <code>filter</code> 这类接受闭包并进行运行的方法一起，<strong>让整个行为变成延时进行的</strong>。在某些情况下这么做也对性能会有不小的帮助。例如，直接使用 map 时：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> data = <span class="number">1</span>...<span class="number">3</span></div><div class="line"><span class="keyword">let</span> result = data.<span class="built_in">map</span> &#123;</div><div class="line">    (i: <span class="type">Int</span>) -&gt; <span class="type">Int</span> <span class="keyword">in</span></div><div class="line">    <span class="built_in">print</span>(<span class="string">"正在处理 \(i)"</span>)</div><div class="line">    <span class="keyword">return</span> i * <span class="number">2</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">print</span>(<span class="string">"准备访问结果"</span>)</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> result &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"操作后结果为 \(i)"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">print</span>(<span class="string">"操作完毕"</span>)</div><div class="line"></div><div class="line"><span class="comment">// 输出：</span></div><div class="line"><span class="comment">// 正在处理 1</span></div><div class="line"><span class="comment">// 正在处理 2</span></div><div class="line"><span class="comment">// 正在处理 3</span></div><div class="line"><span class="comment">// 准备访问结果</span></div><div class="line"><span class="comment">// 操作后结果为 2</span></div><div class="line"><span class="comment">// 操作后结果为 4</span></div><div class="line"><span class="comment">// 操作后结果为 6</span></div><div class="line"><span class="comment">// 操作完毕</span></div></pre></td></tr></table></figure>
<p>而如果我们先进行一次 <code>lazy</code> 操作的话，我们就能得到延时运行版本的容器：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> data = <span class="number">1</span>...<span class="number">3</span></div><div class="line"><span class="keyword">let</span> result = data.<span class="built_in">lazy</span>.<span class="built_in">map</span> &#123;</div><div class="line">    (i: <span class="type">Int</span>) -&gt; <span class="type">Int</span> <span class="keyword">in</span></div><div class="line">    <span class="built_in">print</span>(<span class="string">"正在处理 \(i)"</span>)</div><div class="line">    <span class="keyword">return</span> i * <span class="number">2</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">print</span>(<span class="string">"准备访问结果"</span>)</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> result &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"操作后结果为 \(i)"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">print</span>(<span class="string">"操作完毕"</span>)</div><div class="line"></div><div class="line"><span class="comment">// 准备访问结果</span></div><div class="line"><span class="comment">// 正在处理 1</span></div><div class="line"><span class="comment">// 操作后结果为 2</span></div><div class="line"><span class="comment">// 正在处理 2</span></div><div class="line"><span class="comment">// 操作后结果为 4</span></div><div class="line"><span class="comment">// 正在处理 3</span></div><div class="line"><span class="comment">// 操作后结果为 6</span></div><div class="line"><span class="comment">// 操作完毕</span></div></pre></td></tr></table></figure>
<p>对于那些不需要完全运行，可能提前退出的情况，使用 lazy 来进行性能优化效果会非常有效。</p>
<h2 id="1.2.2"> 编译标记 </h2>

<p>在 Objective-C 中，我们经常在代码中插入 <code>#param</code> 符号来标记代码的区间，这样在 Xcode 的导航栏中我们就可以看到组织分块后的方法列表。在 Swift 中我们可以用 <code>MARK:</code> 来代替：</p>
<p><img src="http://p0kmbfoc8.bkt.clouddn.com/Snip20171207_3.png" alt=""></p>
<p>在 Objective-C 中还有一个很常用的编译标记，那就是 <code>#warning</code>，一个 <code>#warning</code> 标记可以在 Xcode 的代码编辑器中显示为明显的黄色警告条，非常适合用来提示代码的维护者和使用者需要对某些东西加以关注。在 Swift 中我们可以用 <code>FIXME:</code> 和 <code>TODO:</code> 配合 <code>shell</code> 来代替：</p>
<p><img src="http://p0kmbfoc8.bkt.clouddn.com/Snip20171207_8.png" alt=""></p>
<p>脚本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">TAGS=&quot;TODO:|FIXME:&quot;</div><div class="line">echo &quot;searching $&#123;SRCROOT&#125; for $&#123;TAGS&#125;&quot;</div><div class="line">find &quot;$&#123;SRCROOT&#125;&quot; \( -name &quot;*.swift&quot; \) -print0 | xargs -0 egrep --with-filename --line-number --only-matching &quot;($TAGS).*\$&quot; | perl -p -e &quot;s/($TAGS)/ warning: \$1/&quot;</div></pre></td></tr></table></figure>
<p>效果：</p>
<p><img src="http://p0kmbfoc8.bkt.clouddn.com/Snip20171207_7.png" alt=""><br><img src="http://p0kmbfoc8.bkt.clouddn.com/Snip20171207_6.png" alt=""></p>
<h2 id="1.2.3"> 换行符 </h2>

<p>在 Swift 3 中，需要换行时是需要 <code>\n</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> str = <span class="string">"xxxx\nxxx"</span></div><div class="line"></div><div class="line"><span class="comment">// 输出：</span></div><div class="line"><span class="comment">// xxxx</span></div><div class="line"><span class="comment">// xxx</span></div></pre></td></tr></table></figure>
<p>在 swift 4 中，我们可以使用 <code>&quot;&quot;&quot;</code>：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">let jsonStr = """</div><div class="line">        &#123;</div><div class="line">            "id": 123455,</div><div class="line">            "nickname": "xxxx",</div><div class="line">            "isMale": true,</div><div class="line">            "birthday": "2000年3月24日",</div><div class="line">            "personalURL": "https://xxxxxx.github.io"</div><div class="line">        &#125;</div><div class="line">        """</div><div class="line">          </div><div class="line">// 输出：</div><div class="line">&#123;</div><div class="line">    "id": 123455,</div><div class="line">    "nickname": "xxxx",</div><div class="line">    "isMale": true,</div><div class="line">    "birthday": "2000年3月24日",</div><div class="line">    "personalURL": "https://xxxxxx.github.io"</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="1.2.4"> 字符串切割 split </h2>

<p>我们需要切割某个字符串时可以用 <code>split</code> 方法，需要注意的是，返回的结果是个<strong>数组</strong>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> str = <span class="string">"Hello，world !"</span></div><div class="line"><span class="built_in">print</span>(str.<span class="built_in">split</span>(separator: <span class="string">"，"</span>))</div><div class="line"></div><div class="line"><span class="comment">// 输出：</span></div><div class="line"><span class="comment">// ["Hello", "world !"]</span></div></pre></td></tr></table></figure>
<h2 id="1.2.5"> KVC </h2>

<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> name = <span class="string">"ifelseboyxx"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Swift 4 中 Apple 引入了新的 KeyPath 的表达方式，现在，对于类型 <code>MyClass</code> 中的<strong>变量</strong> <code>name</code>，对应的 KeyPath 可以写为 <code>\MyClass.name</code>，利用 KVC 修改 <code>name</code> 值的话，我们可以这么操作：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> object = <span class="type">MyClass</span>()</div><div class="line"><span class="built_in">print</span>(<span class="string">"name: \(object.name)"</span>)</div><div class="line"><span class="comment">// set</span></div><div class="line">object[keyPath: \<span class="type">MyClass</span>.name] = <span class="string">"ifelseboy"</span></div><div class="line"><span class="comment">// get</span></div><div class="line"><span class="built_in">print</span>(<span class="string">"name: \(object[keyPath: \MyClass.name])"</span>)</div><div class="line"></div><div class="line"><span class="comment">// 输出：</span></div><div class="line"><span class="comment">// name: ifelseboyxx</span></div><div class="line"><span class="comment">// name: ifelseboy</span></div></pre></td></tr></table></figure>
<p>另外 Swift 4 中 <code>struct</code> 同样支持 KVC ：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> age: <span class="type">Int</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = <span class="type">MyStruct</span>(age: <span class="number">18</span>)</div><div class="line"><span class="built_in">print</span>(<span class="string">"我今年 \(obj.age) 岁了"</span>)</div><div class="line">obj[keyPath: \<span class="type">MyStruct</span>.age] = <span class="number">8</span></div><div class="line"><span class="built_in">print</span>(<span class="string">"我今年 \(obj[keyPath: \MyStruct.age]) 岁了"</span>)</div><div class="line"></div><div class="line"><span class="comment">// 输出：</span></div><div class="line"><span class="comment">// 我今年 18 岁了</span></div><div class="line"><span class="comment">// 我今年 8 岁了</span></div></pre></td></tr></table></figure>
<h2 id="1.2.6"> Swift 中值类型和引用类型注意点 </h2>

<p>KVC 一节中代码里有个注意点：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = <span class="type">MyStruct</span>(age: <span class="number">18</span>)</div><div class="line"><span class="comment">//替换为</span></div><div class="line"><span class="keyword">let</span> obj = <span class="type">MyStruct</span>(age: <span class="number">18</span>)</div></pre></td></tr></table></figure>
<p>是编译不过的，会报错：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="type">Cannot</span> assign to immutable expression of type '<span class="type">Int'</span></div></pre></td></tr></table></figure>
<p>笔者初次也犯了这样的错误，想当然的认为 <code>MyClass</code> 用 <code>let</code> 声明的是没有问题的，<code>struct</code> 也一样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> object = <span class="type">MyClass</span>()</div></pre></td></tr></table></figure>
<p><strong>其实原因很简单，swift 中 Class 是引用类型的，而 struct 是值类型的：值类型在被赋给一个变量，或被传给函数时，实际是做了一次拷贝。引用类型在被赋给一个变量，或被传给函数时，传递的是引用。</strong></p>
<h2 id="1.2.7"> KVO </h2>

<p>很遗憾，依然只有 <code>NSObject</code> 才能支持 KVO，另外由于 Swift 为了效率，默认禁用了动态派发，因此想用 Swift 来实现 KVO，我们还需要做额外的工作，那就是将想要观测的对象标记为 <code>dynamic</code> 和 <code>@objc</code>，下面的 🌰 是 <code>ViewController</code> 监听 <code>MyClass</code> 的 <code>date</code> 属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>: <span class="title">NSObject</span> </span>&#123;</div><div class="line">    <span class="meta">@objc</span> <span class="keyword">dynamic</span> <span class="keyword">var</span> date = <span class="type">Date</span>()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">var</span> myObject: <span class="type">MyClass</span>!</div><div class="line">    <span class="keyword">var</span> observation: <span class="type">NSKeyValueObservation</span>?</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.viewDidLoad()</div><div class="line">        </div><div class="line">        myObject = <span class="type">MyClass</span>()</div><div class="line">        <span class="built_in">print</span>(<span class="string">"当前日期：\(myObject.date)"</span>)</div><div class="line">    </div><div class="line">        observation = myObject.observe(\<span class="type">MyClass</span>.date, options: [.old,.new], changeHandler: &#123; (<span class="number">_</span>, change) <span class="keyword">in</span></div><div class="line">            <span class="keyword">if</span> <span class="keyword">let</span> newDate = change.newValue , <span class="keyword">let</span> oldDate = change.oldValue &#123;</div><div class="line">                <span class="built_in">print</span>(<span class="string">"日期发生变化 old：\(oldDate) new：\(newDate) "</span>)</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">        </div><div class="line">        <span class="type">DispatchQueue</span>.main.asyncAfter(deadline: <span class="type">DispatchTime</span>.now() + <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">self</span>.myObject.date = <span class="type">Date</span>()</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 输出：</span></div><div class="line"><span class="comment">// 当前日期：2017-12-07 06:31:26 +0000</span></div><div class="line"><span class="comment">// 日期发生变化 old：2017-12-07 06:31:26 +0000 new：2017-12-07 06:31:27 +0000</span></div></pre></td></tr></table></figure>
<p>在 Objective-C 中我们几乎可以没有限制地对所有满足 KVC 的属性进行监听，<strong>而现在我们需要属性有 <code>dynamic</code> 和 <code>@objc</code> 进行修饰</strong>。大多数情况下，我们想要观察的类包含这两个修饰 (除非这个类的开发者有意为之，否则一般也不会有人愿意多花功夫在属性前加上它们，因为这毕竟要损失一部分性能)，并且有时候我们很可能也无法修改想要观察的类的源码。遇到这样的情况的话，<strong>一个可能可行的方案是继承这个类并且将需要观察的属性使用 <code>dynamic</code> 和 <code>@objc</code> 进行重写。</strong>比如刚才我们的 <code>MyClass</code> 中如果 <code>date</code> <strong>没有相应标注的话</strong>，我们可能就需要一个新的 <code>MyChildClass</code>了： </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>: <span class="title">NSObject</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> date = <span class="type">Date</span>()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyChildClass</span>: <span class="title">MyClass</span> </span>&#123;</div><div class="line">    <span class="meta">@objc</span> <span class="keyword">dynamic</span> <span class="keyword">override</span> <span class="keyword">var</span> date: <span class="type">Date</span> &#123;</div><div class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="keyword">super</span>.date &#125;</div><div class="line">        <span class="keyword">set</span> &#123; <span class="keyword">super</span>.date = newValue &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">var</span> myObject: <span class="type">MyChildClass</span>!</div><div class="line">    <span class="keyword">var</span> observation: <span class="type">NSKeyValueObservation</span>?</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.viewDidLoad()</div><div class="line">        </div><div class="line">        myObject = <span class="type">MyChildClass</span>()</div><div class="line">        <span class="built_in">print</span>(<span class="string">"当前日期：\(myObject.date)"</span>)</div><div class="line">    </div><div class="line">        observation = myObject.observe(\<span class="type">MyChildClass</span>.date, options: [.old,.new], changeHandler: &#123; (<span class="number">_</span>, change) <span class="keyword">in</span></div><div class="line">            <span class="keyword">if</span> <span class="keyword">let</span> newDate = change.newValue , <span class="keyword">let</span> oldDate = change.oldValue &#123;</div><div class="line">                <span class="built_in">print</span>(<span class="string">"日期发生变化 old：\(oldDate) new：\(newDate) "</span>)</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">        </div><div class="line">        <span class="type">DispatchQueue</span>.main.asyncAfter(deadline: <span class="type">DispatchTime</span>.now() + <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">self</span>.myObject.date = <span class="type">Date</span>()</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 输出：</span></div><div class="line"><span class="comment">// 当前日期：2017-12-07 06:36:50 +0000</span></div><div class="line"><span class="comment">// 日期发生变化 old：2017-12-07 06:36:50 +0000 new：2017-12-07 06:36:51 +0000</span></div></pre></td></tr></table></figure>
<h2 id="1.2.8"> Swift UIButton 状态的叠加 </h2> 

<p>在 Objective-C 中，如果我们想叠加按钮的某个状态，可以这么写：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UIButton</span> * button = [<span class="built_in">UIButton</span> buttonWithType:<span class="built_in">UIButtonTypeCustom</span>];</div><div class="line">[button setTitle:<span class="string">@"Test"</span> forState:<span class="built_in">UIControlStateNormal</span> | <span class="built_in">UIControlStateSelected</span>];</div></pre></td></tr></table></figure>
<p>对应的 Swift 我们可以这么写：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> btn = <span class="type">UIButton</span>.<span class="keyword">init</span>(type: .custom)</div><div class="line">btn.setTitle(<span class="string">"hehe"</span>, <span class="keyword">for</span>: [.normal ,.selected])</div></pre></td></tr></table></figure>
<p>把需要叠加的状态用个<strong>数组</strong>装起来就行了。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2017/11/30/hook_system_delegate/" class="next">下一篇</a></div><div id="container"></div><script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><script>var gitment = new Gitment({
  id: window.location.pathname,
  owner: 'ifelseboyxx',
  repo: 'ifelseboyxx.github.io',
  oauth: {
    client_id: '8dc253d5704a97b4fca5',
    client_secret: '1153e9f492111d9cfee01cdc285c0e59caceb1db'
  }
});
gitment.render('container');</script><div class="copyright"><p>© 2016 - 2017 <a href="http://blog.ifelseboyxx.com/">ifelseboyxx</a> | Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>